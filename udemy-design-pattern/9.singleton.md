> 이 내용은 udemy의 design pattern 강의를 정리한 것입니다.
>
> https://www.udemy.com/course/design-patterns-in-java-concepts-hands-on-projects/



# 싱글톤(Singleton) 패턴

## 싱글톤은 무엇인가?

* 싱글톤 클래스는 단일 지점을 통해 접근할 수 있는 오직 하나의 인스턴스만 가지고 있다. (메서드/필드)
* 이 패턴이 해결하려는 주된 문제는 이 클래스의 하나의 인스턴스만 존재한다는 것을 확인하는 것이다.
* 싱글톤에 추가하는 어떤 상태도 애플리케이션의 전역 상태의 일부가 된다.



## 싱글톤 구현 방법

* 인스턴스 생성 제어
    * 클래스 생성자는 전역에서 접근되어서는 안된다.
    * 서브 클래싱/상속은 허용되지 않는다.
* 인스턴스 정보 기록
    * 클래스 자체에 기록
* 싱글톤 인스턴스로의 접근
    * public static 메소드로 접근
    * final public static 필드로 인스턴스를 노출할 수는 있으나 모든 싱글톤 구현에서 맞는 방법은 아니다.



* 싱글톤을 구현하는 두가지 방법
    * 빠른(Early) 초기화 - Eager 싱글톤
        * 클래스가 로드될 때 싱글톤 생성
    * 느린(Lazy) 초기화 - Lazy 싱글톤
        * 처음 사용될 때 싱글톤 생성



## 싱글톤 구현

### Eager 초기화 방법

Eager 초기화를 사용하는 방법은 인스턴스를 클래스에서 미리 생성해 놓고 이를 접근할 수 있는 메소드를 제공하는 방법이다.

```java
/**
 * 싱글톤 인스턴스로 eager 초기화를 사용한다.
 */
public class EagerRegistry {

    private EagerRegistry() {}

    private static final EagerRegistry INSTANCE = new EagerRegistry(); // 미리 생성해 놓는다.

    public static EagerRegistry getInstance() {
        return INSTANCE;
    }
}
```

이를 사용하는 Client 코드는 아래와 같다.

```java
public class Client {

    public static void main(String[] args) {
        EagerRegistry registry = EagerRegistry.getInstance(); // 인스턴스 생성
        EagerRegistry registry2 = EagerRegistry.getInstance(); // 또 다른 인스턴스 생성

        System.out.println(registry == registry2); // true <= 항상 같은 인스턴스
    }
}
```



### Lazy 초기화 방법

 * 이 클래스는 Double Checked Locking 사용하는, 전통적인 싱글톤 방법을 나타낸다.
 * 또한 lazy 초기화 싱글톤이다.
 * 이 구현방법이 volatile과 double check locking을 사용한 lazy 초기화로 멀티쓰레드 이슈를 해결할 수는 있지만, volatile 키워드는 Java 1.5 이상에서만 동작한다.

```java
public class LazyRegistryWithDCL {

    private LazyRegistryWithDCL() {
    }

    // volatile 키워드는 CPU 캐쉬값을 사용하지 않고 메모리를 접근하도록 한다.
    private static volatile LazyRegistryWithDCL INSTANCE;

    public static LazyRegistryWithDCL getInstance() {
        if (INSTANCE == null) {
            synchronized (LazyRegistryWithDCL.class) {
                if (INSTANCE == null) {
                    INSTANCE = new LazyRegistryWithDCL();
                    // 기본적으로 멀티 쓰레드 환경에서는 CPU 레지스터에 변수 값을 저장한다.
                }
            }
        }

        return INSTANCE;
    }
}
```

이를 사용하는 Client 코드는 아래와 같다.

```java
public class Client {

    public static void main(String[] args) {
        LazyRegistryWithDCL lazySignleton1 = LazyRegistryWithDCL.getInstance();
        LazyRegistryWithDCL lazySignleton2 = LazyRegistryWithDCL.getInstance();

        System.out.println(lazySignleton1 == lazySignleton2); // true
    }
}
```



### Holder로 Lazy 초기화 방법

 * Holder 클래스를 사용한 lazy 초기화 싱글톤 패턴
 * 이 방법은 동기화를 신경쓸 필요없는 lazy 초기화 방법이다.
 * INSTANCE는 getInstance()를 사용할 때까지는 생성이 되지 않는다.

```java
public class LazyRegistryIODH {

    private LazyRegistryIODH() {
        System.out.println("In LazyRegistryIODH singleton");
    }

    private static class RegistryHolder {
        static LazyRegistryIODH INSTANCE = new LazyRegistryIODH();
    }

    public static LazyRegistryIODH getInstance() {
        return RegistryHolder.INSTANCE;
    }
}
```

이를 사용하는 Client 코드는 아래와 같다.

```java
public class Client {

    public static void main(String[] args) {
        LazyRegistryIODH singleton = LazyRegistryIODH.getInstance();
        LazyRegistryIODH singleton2 = LazyRegistryIODH.getInstance();
        LazyRegistryIODH singleton3 = LazyRegistryIODH.getInstance();
        LazyRegistryIODH singleton4 = LazyRegistryIODH.getInstance();
        // In LazyRegistryIODH singleton <== 한번만 호출된다.
    }
}
```

여러번 사용이 되더라도 한번만 생성이 된다.



### Enum을 이용한 싱글톤 생성



