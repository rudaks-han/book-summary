# 1 What's Wrong with Layers?

과거에 레이어 방식(웹)의 애플리케이션을 개발해 본 적이 있을 것이다. 또한 지금 프로젝트에도 적용고 있을지도 모른다. (실제로 나는 지금도 하고 있다)

레이어에 대한 생각은 컴퓨터 과학 분야, 튜토리얼, 모범 사례 등에 많이 녹아 들어왔다. 심지어 책에서도 배웠었다. (*Software Architecture Patterns by Mark Richards, O'Reilly, 2015*)



<img src="chapter-01.assets/image-20201222063052170.png" alt="image-20201222063052170" style="zoom:67%;" />

[그림 1-1] 웹 레이어, 도메인 레이어, 퍼시스턴시 레이어로 구성된 전통적인 웹 애플리케이션 아키텍처



위의 그림은 일반적인 3개 계층으로 구성된 고수준의 뷰를 표시한다. 웹 레이어는 요청을 받아서 도메인 혹은 비즈니스 레이어 서비스로 전달한다. 서비스는 비즈니스를 수행하고 퍼시스턴시 레이어의 콤포넌트를 호출하여 도메인 엔터티 상태를 조회하거나 수정하는 역할은 한다.

레이어는 solid 아키텍처 패턴이다는 걸 아느냐? 제대로 작성한다면 도메인 레이어는 웹과 퍼시스턴스 레이어와는 독립적으로 만들 수 있다. 또한 웹과 퍼시스턴시 기술을 도메인 로직과 무관하게 변경할 수 있다. 기존 피처에 영향을 주기 않고 새로운 피처를 추가할 수도 있다.

좋은 레이어드 아키텍처로는 선택사항과 요구사항들을 변경하는데 쉽게 적용할 수 있다. 그리고 Uncle Bob을 신봉한다면 이것이 아키텍처에 대한 모든것을 말하는 것이다. (*Clean Architecture by Robert C.Martin*)

그래서, 레이어에 무슨 문제가 있는 걸까?

내 경험상, 레이어드 아키텍처는 나쁜 습관이 생겨서 시간이 지남에 따라 고치기 어렵게 하는 측면을 가지고 있다. 다음 섹션에서 이유를 말할 것이다.



## It Promotes Database-Driven Design

정의에 의하면 전통적인 레이어드 아키텍처의 기본은 데이터베이스이다.

웹 레이어는 도메인에 의존하고 있고 차례로 퍼시스턴시 즉 데이터베이스에 의존한다.

모든 것이 퍼시스턴시 레이어 위에 존재한다. 이것은 여러가지 이유로 문제가 있다.

우리가 만들고 있는 애플리케이션에 무엇을 만들것인지 다시 되돌려서 생각해보자. 전형적으로 규칙 모델 혹은 사용자들과 좀 더 쉽게 상호작용하기 위한 비즈니스를 조절하는 ''정책'을 만들고 있는 것이다.

주로 상태가 아닌 행위를 모델링 하고 있다. 그렇다. 상태는 애플리케이션에서 중요한 부분이지만, 행위는 상태를 변화시키고 비즈니스를 이끌고 있다.

그럼 왜 도메인 로직이 아니라 데이타베이스가 아키텍처의 기본이 되게 만든다는 말인가?

과거 애플리케이션에서 만들었던 유스케이스를 생각해보자. 도메인 로직 혹은 퍼시스턴시 레이어 중 어느 것을 먼저 만들기 시작했는가? 대부분은 데이터베이스 구조를 만들었고 그 위에 도메인 로직을 구현했을 것이다.

의존관계가 자연스럽게 흘르가기 때문에 전통적인 레이어 아키텍처에서는 이치에 맞았다. 그러나 비즈니스 관점에서는 절대적으로 맞지 않다. 그 어느것 보다 도메인 로직을 우선 만들어어야 한다.

데이터베이스 중심 아키텍처 관점에서 주도적인 힘은 ORM(Object Relational Mapping) 프레임워크다. 오해하지마라. 난 이 프레임워크를 좋아하고 매일 JPA와 Hibernate를 사용하고 있다.

그러나 ORM 프레임워크와 레이어드 아키텍처를 결합한다면 비즈니스 룰과 퍼시스턴시 관점을 쉽게 섞어버릴 유혹에 현혹된다.



<img src="chapter-01.assets/image-20201222072040297.png" alt="image-20201222072040297" style="zoom:67%;" />

[그림 1-2] 도메인 레이어에 데이터베이스 엔티티 사용은 퍼시스턴시 레이어와의 강한 커플링을 유도한다.



일반적으로, 위의 그림에서 나타난대로, 퍼시스턴시 레이어에 ORM 관리 엔터티를 가지고 있다. 레이어가 그 하위 레이어로 접근하기 때문에 도메인 레이어는 엔티티에 접근하도록 허용된다. 사용되도록 허용된다면 엔티티들은 사용될 것이다.

이것은 퍼시스턴시 레이어와 도메인 레이어 사이의 강한 커플링을 만들어낸다. 서비스는 퍼시스턴시 모델을 비즈니스 모델로 사용하고 도메인 로직을 처리할 뿐 아니라 eager/lazy 로딩같은 기술도 사용할 것이고, 데이터베이스 트랜잭션, flush cache, 유사한 내부 작업들도 사용할 것이다.

퍼시스턴시 코드는 도메인 코드에 녹아들게 되며 서로 변경하기 어려워진다. 이것은 우리의 아키텍처의 목표가 되어야 할 유연성과 개방성과는 정반대 현상이 되는 것이다.



## It's Prone to Shortcuts

전통적인 레이어드 아키텍처에는, 어떤 레이어에서 동일 레이어 혹은 그 하위 레이어로만 접근할 수 있다는 공통 규칙이 있다.

개발팀이 합의한 다른 규칙, 툴에 의해 강제될지도 모르지만 레이어드 아키텍처 그자체로는 어떤 규칙도 없다.

레이어드 아키텍처에서 상위의 어떤 컴포넌트에 접근이 필요하다면, 컴포넌트를 레이어 하위에 내려서 문제를 해결할 수 있다.

한번 하는 것은 좋지만 한번 한다는 것은 두번할 수 있다는 여지를 남겨주는 것이다. 누군가 그렇게 할 수도 있다는 말이다.

나는 개발자로 그렇게 하는 지름길 같은걸 말하는 것은 아니다. 그렇게 할 선택사항이 있다면 어느 누가 그렇게 할 수도 있다는 것이다. 전에 한 적이 있다면 누군가 다시 그렇게 할 수 있다는 것이다. 이것은 "깨진 유리창 이론"이라고 불리는 심리학적 효과이다.



<img src="chapter-01.assets/image-20201222073945165.png" alt="image-20201222073945165" style="zoom:67%;" />

[그림 1-3] 퍼시스턴시 레이어에 모든 것을 사용할 수 있기 때문에 시간이 지남에 따라 점점 비대해진다.



소프트웨어 프로젝트 개발과 유지보수의 시간이 지남에 따라, 퍼시스턴시 레이어는 위의 그림과 같이 될 가능성이 많다.

퍼시스턴시 레이어는 컴포넌트를 바닥에 둠으로서 점점 비대해진다. 헬퍼나 유틸리티 컴포넌트는 어떤 레이어에 포함되지 않기 때문에 해당 대상이 될 가능성이 큰 후보이다.

그럼, 아키텍처에서 "shortcut mode"를 못하게 하려면, 레이어는 좋은 선택사항이 아니다. 적어도 추가적인 아키텍처 규칙을 강제하지 않고는 아니다는 말이다. 그리고 "강제"라는 말의 의미는 시니어 개발자가 코드리뷰를 하라는 의미는 아니고 빌드 실패를 할 수 있는 규칙을 의미하는 것이다.



## It Grows Hard to Test

레이어드 아키텍처의 일반적인 진화는 레이어는 <u>skipped된다는 것이다.</u> 웹 레이어에서 퍼시스턴시 레이어를 접근할 때 단일 엔티티를 조작하기 때문에 도메인 레이어를 거치지 않아도 된다는 말이지 않는가?



<img src="chapter-01.assets/image-20201222074953590.png" alt="image-20201222074953590" style="zoom:67%;" />

[그림 1.4] 도메인 레이어 <u>skip하는 것은</u> 코드상 도메인 로직이 흩어지는 경향이 있다.



<u>Again, this feels ok the first couple of times,</u> 그러나 종종 발생한다면 두가지 단점이 있다.

첫번째, 단일 필드를 조작할지라도 웹 레이어에서 도메인 로직을 구현하고 있다. 향후에 유스케이스가 확장되면 어떻게 할 것인가? 애플리케이션 전반적으로 책임과 필수 도메인 로직을 혼합하여 웹 레이어에 도메인 로직을 추가할 가능성이 많다.

두번째, 웹 레이어 테스트 관점에서, 도메인 레이어 뿐만 아니라 퍼시스턴시 레이어에 mock을 해야 한다. 이것은 단위테스트상 복잡성을 야기시킨다. 복잡한 테스트 준비과정이 첫번째 단계이다. 

웹 컴포넌트기 시간이 지남에 따라 점점 커짐으로써 다른 퍼시스턴시 컴포넌트의 의존성이 많아질 것이고 테스트 복잡성을 추가할 것이다. 어떤 관점에서는 실제 테스트 코드를 작성하는 것보다 의존성을 이해하고 mocking하는데 더 많은 시간이 걸릴 것이다.



## It Hides the Use Cases

개발자로써, 우리는 새로운 유스케이스를 구현하는 새로운 코드를 만들고 싶어한다. 그러나 새로운 코드를 작성하는 것보다 일반적으로 기존 코드 변경하는데 더 많은 시간이 소요된다. 

































