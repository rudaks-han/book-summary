# 1 What's Wrong with Layers?

과거에 계층형 방식(웹)의 애플리케이션을 개발해 본 적이 있을 것이다. 또한 지금 프로젝트에도 적용고 있을지도 모른다. (실제로 나는 지금도 하고 있다)

레이어에 대한 생각은 컴퓨터 과학 분야, 튜토리얼, 모범 사례 등에 많이 녹아 들어왔다. 심지어 책에서도 배웠었다. (*Software Architecture Patterns by Mark Richards, O'Reilly, 2015*)



<img src="chapter-01.assets/image-20201222063052170.png" alt="image-20201222063052170" style="zoom:67%;" />

[그림 1-1] 웹 레이어, 도메인 레이어, 퍼시스턴시 레이어로 구성된 전통적인 웹 애플리케이션 아키텍처



위의 그림은 일반적인 3개 계층으로 구성된 고수준의 뷰를 표시한다. 웹 레이어는 요청을 받아서 도메인 혹은 비즈니스 레이어 서비스로 전달한다. 서비스는 비즈니스를 수행하고 퍼시스턴시 레이어의 콤포넌트를 호출하여 도메인 엔터티 상태를 조회하거나 수정하는 역할은 한다.

레이어는 solid 아키텍처 패턴이다는 걸 아느냐? 제대로 작성한다면 도메인 레이어는 웹과 퍼시스턴스 레이어와는 독립적으로 만들 수 있다. 또한 웹과 퍼시스턴시 기술을 도메인 로직과 무관하게 변경할 수 있다. 기존 피처에 영향을 주기 않고 새로운 피처를 추가할 수도 있다.

좋은 레이어드 아키텍처로는 선택사항과 요구사항들을 변경하는데 쉽게 적용할 수 있다. 그리고 Uncle Bob을 신봉한다면 이것이 아키텍처에 대한 모든것을 말하는 것이다. (*Clean Architecture by Robert C.Martin*)

그래서, 레이어에 무슨 문제가 있는 걸까?

내 경험상, 레이어드 아키텍처는 나쁜 습관이 생겨서 시간이 지남에 따라 고치기 어렵게 하는 측면을 가지고 있다. 다음 섹션에서 이유를 말할 것이다.



## It Promotes Database-Driven Design

정의에 의하면 전통적인 레이어드 아키텍처의 기본은 데이터베이스이다.

웹 레이어는 도메인에 의존하고 있고 차례로 퍼시스턴시 즉 데이터베이스에 의존한다.

모든 것이 퍼시스턴시 레이어 위에 존재한다. 이것은 여러가지 이유로 문제가 있다.

우리가 만들고 있는 애플리케이션에 무엇을 만들것인지 다시 되돌려서 생각해보자. 전형적으로 규칙 모델 혹은 사용자들과 좀 더 쉽게 상호작용하기 위한 비즈니스를 조절하는 ''정책'을 만들고 있는 것이다.

주로 상태가 아닌 행위를 모델링 하고 있다. 그렇다. 상태는 애플리케이션에서 중요한 부분이지만, 행위는 상태를 변화시키고 비즈니스를 이끌고 있다.

그럼 왜 도메인 로직이 아니라 데이타베이스가 아키텍처의 기본이 되게 만든다는 말인가?

과거 애플리케이션에서 만들었던 유스케이스를 생각해보자. 도메인 로직 혹은 퍼시스턴시 레이어 중 어느 것을 먼저 만들기 시작했는가? 대부분은 데이터베이스 구조를 만들었고 그 위에 도메인 로직을 구현했을 것이다.

의존관계가 자연스럽게 흘르가기 때문에 전통적인 레이어 아키텍처에서는 이치에 맞았다. 그러나 비즈니스 관점에서는 절대적으로 맞지 않다. 그 어느것 보다 도메인 로직을 우선 만들어어야 한다.

데이터베이스 중심 아키텍처 관점에서 주도적인 힘은 ORM(Object Relational Mapping) 프레임워크다. 오해하지마라. 난 이 프레임워크를 좋아하고 매일 JPA와 Hibernate를 사용하고 있다.

그러나 ORM 프레임워크와 레이어드 아키텍처를 결합한다면 비즈니스 룰과 퍼시스턴시 관점을 쉽게 섞어버릴 유혹에 현혹된다.



<img src="chapter-01.assets/image-20201222072040297.png" alt="image-20201222072040297" style="zoom:67%;" />

[그림 1-2] 도메인 레이어에 데이터베이스 엔티티 사용은 퍼시스턴시 레이어와의 강한 커플링을 유도한다.



일반적으로, 위의 그림에서 나타난대로, 퍼시스턴시 레이어에 ORM 관리 엔터티를 가지고 있다. 레이어가 그 하위 레이어로 접근하기 때문에 도메인 레이어는 엔티티에 접근하도록 허용된다. 사용되도록 허용된다면 엔티티들은 사용될 것이다.

이것은 퍼시스턴시 레이어와 도메인 레이어 사이의 강한 커플링을 만들어낸다. 서비스는 퍼시스턴시 모델을 비즈니스 모델로 사용하고 도메인 로직을 처리할 뿐 아니라 eager/lazy 로딩같은 기술도 사용할 것이고, 데이터베이스 트랜잭션, flush cache, 유사한 내부 작업들도 사용할 것이다.

퍼시스턴시 코드는 도메인 코드에 녹아들게 되며 서로 변경하기 어려워진다. 이것은 우리의 아키텍처의 목표가 되어야 할 유연성과 개방성과는 정반대 현상이 되는 것이다.



## It's Prone to Shortcuts

전통적인 레이어드 아키텍처에는, 어떤 레이어에서 동일 레이어 혹은 그 하위 레이어로만 접근할 수 있다는 공통 규칙이 있다.

개발팀이 합의한 다른 규칙, 툴에 의해 강제될지도 모르지만 레이어드 아키텍처 그자체로는 어떤 규칙도 없다.

레이어드 아키텍처에서 상위의 어떤 컴포넌트에 접근이 필요하다면, 컴포넌트를 레이어 하위에 내려서 문제를 해결할 수 있다.

한번 하는 것은 좋지만 한번 한다는 것은 두번할 수 있다는 여지를 남겨주는 것이다. 누군가 그렇게 할 수도 있다는 말이다.

나는 개발자로 그렇게 하는 지름길 같은걸 말하는 것은 아니다. 그렇게 할 선택사항이 있다면 어느 누가 그렇게 할 수도 있다는 것이다. 전에 한 적이 있다면 누군가 다시 그렇게 할 수 있다는 것이다. 이것은 "깨진 유리창 이론"이라고 불리는 심리학적 효과이다.



<img src="chapter-01.assets/image-20201222073945165.png" alt="image-20201222073945165" style="zoom:67%;" />

[그림 1-3] 퍼시스턴시 레이어에 모든 것을 사용할 수 있기 때문에 시간이 지남에 따라 점점 비대해진다.



소프트웨어 프로젝트 개발과 유지보수의 시간이 지남에 따라, 퍼시스턴시 레이어는 위의 그림과 같이 될 가능성이 많다.

퍼시스턴시 레이어는 컴포넌트를 바닥에 둠으로서 점점 비대해진다. 헬퍼나 유틸리티 컴포넌트는 어떤 레이어에 포함되지 않기 때문에 해당 대상이 될 가능성이 큰 후보이다.

그럼, 아키텍처에서 "shortcut mode"를 못하게 하려면, 레이어는 좋은 선택사항이 아니다. 적어도 추가적인 아키텍처 규칙을 강제하지 않고는 아니다는 말이다. 그리고 "강제"라는 말의 의미는 시니어 개발자가 코드리뷰를 하라는 의미는 아니고 빌드 실패를 할 수 있는 규칙을 의미하는 것이다.



## It Grows Hard to Test

레이어드 아키텍처의 일반적인 진화는 레이어는 <u>skipped된다는 것이다.</u> 웹 레이어에서 퍼시스턴시 레이어를 접근할 때 단일 엔티티를 조작하기 때문에 도메인 레이어를 거치지 않아도 된다는 말이지 않는가?



<img src="chapter-01.assets/image-20201222074953590.png" alt="image-20201222074953590" style="zoom:67%;" />

[그림 1.4] 도메인 레이어 <u>skip하는 것은</u> 코드상 도메인 로직이 흩어지는 경향이 있다.



<u>Again, this feels ok the first couple of times,</u> 그러나 종종 발생한다면 두가지 단점이 있다.

첫번째, 단일 필드를 조작할지라도 웹 레이어에서 도메인 로직을 구현하고 있다. 향후에 유스케이스가 확장되면 어떻게 할 것인가? 애플리케이션 전반적으로 책임과 필수 도메인 로직을 혼합하여 웹 레이어에 도메인 로직을 추가할 가능성이 많다.

두번째, 웹 레이어 테스트 관점에서, 도메인 레이어 뿐만 아니라 퍼시스턴시 레이어에 mock을 해야 한다. 이것은 단위테스트상 복잡성을 야기시킨다. 복잡한 테스트 준비과정이 첫번째 단계이다. 

웹 컴포넌트기 시간이 지남에 따라 점점 커짐으로써 다른 퍼시스턴시 컴포넌트의 의존성이 많아질 것이고 테스트 복잡성을 추가할 것이다. 어떤 관점에서는 실제 테스트 코드를 작성하는 것보다 의존성을 이해하고 mocking하는데 더 많은 시간이 걸릴 것이다.



## It Hides the Use Cases

개발자로써, 우리는 새로운 유스케이스를 구현하는 새로운 코드를 만들고 싶어한다. 그러나 새로운 코드를 작성하는 것보다 일반적으로 기존 코드 변경하는데 더 많은 시간이 소요된다. 이것은 지난 수년동안 작업해온 끔직한 레거시 프로젝트에 해당될 뿐 아니라 최초 개발이 진행된 신생 프로젝트에도 해당된다.

기능 추가 및 변경에 <u>적합한 장소를 찾기때문에</u> 아키텍처는 코드를 재빠르게 찾게 도움을 줄 수 있어야 한다. 계층형 아키텍처는 이것과 관련해서 <u>어떻게 유지되고 있어야 할까?</u>

<u>이미 논의된 대로, 계층형 아키텍처에서 도메인 로직은 계층 간에 쉽게  흩어질 수 있다. 사용하기 쉬운 케이스에 도메인 로직을 간과한다면 웹 레이어에 존재할 지도 모르겠다. 그리고 어떤 컴포넌트를 도메인과 퍼시스턴시 레이어에서 쉽게 접근된다면 퍼시스턴시 레이어에 있을지도 모르겠다.</u> 이것은 이미 새 기능 추가를 힘들게 하는 요인이다.

<u>더한 것이 있다</u>. 레이어드 아키텍처는 도메인 서비스의 범위에 어떤 규칙을 제약하지 않는다. 시간이 지남에 따라, 아래 그림에서 나타낸대로 다양한 케이스를 처리할 수 있는 폭넒은 서비스가 될 수 있다.



<img src="chapter-01.assets/image-20201222210312642.png" alt="image-20201222210312642" style="zoom:67%;" />

[그림 1.5] 넓은 범위의 서비스는 코드에서 특정 유스 케이스를 찾기 어렵다



넓은 범위의 서비스는 퍼시스턴스 레이어에서 많은 의존성을 가지고  그것을 의존하는 웹 페이어에 많은 컴포넌트를 가지게 된다. 또한 서비스 테스트를 어렵게 할 뿐더러 작업하는 유스케이스에 해당되는 서비스를 찾기도 어렵게 된다.

만일 도메인 서비스를 하나의 유스케이스만 처리하도록 범위를 좁힌다면 얼마나 사용하기 쉬울까? UserService에서 사용자 등록 유스케이스를 찾는 대신에 단지 RegisterUserService를 찾아서 작업할 것이다.



## It Makes Parallel Work Difficult

일반적으로 경영진들은 특정 날짜에 소프트웨어가 완료되기를 기대한다. 실제로, 특정 예산범위 내에서 완료되길 기대하지만 <u>문제를 복잡하게 하지 않는다.</u>

소프트웨어 개발자로의 경력에서 완료된 소프트웨어를 본적이 없다는 사실은 제쳐두더라도 일반적으로 특정일에 완료된다는 것은 병렬로 작업이 진행되어야 한다는 것을 의미한다.

아마 이 책을 읽지 않았어도 "Man-Month의 미신"이라는 명언을 알고 있을 것이다.

>  "뒤처진 소프트웨어 프로젝트에 인력을 투입하는 것은 프로젝트를 더 늦게 만드는 것이다"  - The Mythical Man-Month:

뒤처지지 않은 프로젝트에서는 어느 정도는 사실이다. 50명의 개발자 그룹이 10명의 개발자의 5배가 될거라도 기대해서는 안된다. 대규모 애플리케이션으로 작업하고 있고 하위 팀으로 나누고 소프트웨어를 세부화해서 작업한다면 가능할지도 모르겠지만 대부분의 경우는 <u>stand on each others's feet할 것이다.</u>

적절한 규모에서는 인력이 많으면 더 빠를 것이라고 기대할 수 있다. 경영진들이 우리에게 기다하는 것들이 바로 그것이다.

이 기대에 부응하기 위해 아키텍처는 병렬작업을 지원해야 한다. 이것은 쉬운 작업이 아니다. 레이어드 아키텍처는 실제 도움이 되지 않는다.

애플리케이션에 신규 기능을 추가한다고 생각해보자. 가용 인력 세 명의 개발자가 있다. 한명은 웹 레이어에 도메인 레이어에 한명, 세번째는 퍼시스턴스 레이어에 한명, 이렇게 피처를 추가할 수 있지 않을까?

레이어드 아키텍터에서는 그런 방식은 잘 되지 않는다. 퍼시스턴스 레이어상에서 모든 것이 빌드가 되므로 퍼시스턴스 레이어가 가장 먼저 개발되어야 한다. 그리고 나서 도메인 레이어, 그리고 웹 레이어 순으로 개발된다. 그래서 한명의 개발자만 동시에 피처를 개발할 수 있다.

그러나, 개발자들은 인터페이스를 먼저 정의할 수도 있고 각 개발자들은 실제 구현을 기다리지 않고 인터페이스로 작업을 진행할 수도 있다. 물론 가능하지만 앞에서 논의된 대로 데이터 주도 설계를 하고 있지 않다면 퍼시스턴스 로직은 도메인 로직과 복잡하게 엮여서 각각 관점에 맞게 작업이 불가능할 것이다.

코드 상에서 넓은 범위의 서비스가 있다면,  다른 피처를 병렬로 작업하는 것은 이미 힘들것이다. 또다른 유스케이스 작업은 동일 서비스가 병렬로 수정을 유발할 것이다. merge conflict를 유발하여 잠재적으로 퇴행이 될 것이다.



## How Does This Help Me Build Maintainable Software?

과거에 레이어드 아키텍처를 만들었다면 이 장에서 언급된 몇가지 단점과 관련이 있을 것이고 더 있을 수도 있다.

올바르게 작업이 진행되고 규칙들이 존재했다면 레이어드 아키텍처는 지속될 수 있을 것이다.

그러나, 여기서 말한 논의 내용은 레이어드 아키텍처가 잘못 되는 것들에 대해 이야기한다. 엄격한 자가 훈련 없이는 시간이 지남에 따라 유지될 수 없고 무너지기 쉽다. 매니저가 개발팀에게 개발 만기일로 압박하게 되면 이러한 자가 훈련은 느슨하게 될 수 밖에 없다.

레이어드 아키텍처의 함정을 생각해봄으로써 다음번 더 나은 지속가능한 솔루션의 해결책으로 논의할 때 도움이 될 것이다.  (레이어드 아키텍처이던 다른 아키텍처 스타일이던 상관없이)



































