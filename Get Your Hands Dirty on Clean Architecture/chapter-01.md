# 1 What's Wrong with Layers?

예전에 계층형(웹) 애플리케이션을 개발해 본 적이 있을 것이다. 또한 지금 프로젝트에도 적용하고 있을지도 모르겠다. (실제로 난 지금도 하고 있다)

계층에 대한 사상은 컴퓨터 과학 분야, 교육 안내서, 모범 사례 등에 많이 녹아 들어왔다. 심지어 책에서도 배웠었다. (*Software Architecture Patterns by Mark Richards, O'Reilly, 2015*)



<img src="chapter-01.assets/image-20201222063052170.png" alt="image-20201222063052170" style="zoom:67%;" />

[그림 1.1] 전통적인 웹 애플리케이션 아키텍처는 웹 계층, 도메인 계층, 영속성 계층으로 구성되어 있다.



앞의 그림은 일반적인 3개 계층으로 구성된 고수준의 뷰를 나타난다. 웹 계층은 요청을 받아서 도메인 혹은 비즈니스 계층의 서비스로 전달한다. 서비스는 비즈니스를 수행하고 영속성 계층의 컴포넌트를 호출하여 도메인 엔티티 상태를 조회하거나 수정하는 역할을 한다.

바로 그거다. 계층은 견고한 아키텍처 패턴이다. 제대로 작성한다면, 웹과 영속성 계층과는 독립적인 도메인 계층을 만들 수 있다. 또한 웹과 영속성 기술을 도메인 로직과 무관하게 언제나 변경할 수 있다. 기존 기능에 영향을 주지 않고 새 기능을 추가할 수도 있다.

좋은 계층형 아키텍처는, 선택사항들의 범위를 넓힐 수 있고 요구사항과 외부 요인을 변경하는데 쉽게 적용할 수 있다. 그리고 Uncle Bob의 견해를 믿는다면, 이것이 아키텍처에 대한 모든 것을 말하는 내용이다. (*Clean Architecture by Robert C.Martin*)

그래서, 계층형 구조에 무슨 문제가 있는 걸까?

내 경험상, 계층형 아키텍처는 좋지 않은 코드 스타일이 생기면 시간이 지남에 따라 점점 고치기 어렵게 하는 <u>측면</u>을 가지고 있다. 다음 장에서 그 이유를 설명할 것이다.



## It Promotes Database-Driven Design

정의에 의하면 전통적인 계층형 아키텍처의 기본은 데이터베이스이다.

웹 계층은 도메인 계층에 의존하고  차례로 영속성 레이어 즉 데이터베이스에 의존한다.

모든 것이 영속성 계층 위에 존재한다. 여러가지 이유로 이러한 것들이 문제가 된다.

우리가 만드는 애플리케이션에서 무엇을 만들것인지 잠시 곰곰히 생각해보자. 우리는 일반적으로 사용자들과 상호작용을 하기 위해서 어떠한 비즈니스를 결정하는 규칙이나 "정책"을 만든다. 

우리는 주로 상태(state)가 아닌 행위(behavior)를 모델링 하고 있다. 그렇다, 상태(state)도 애플리케이션에서 중요하지만, 행위가 상태를 변화시키고 비즈니스를 주도하는 것이다.

그러면, 우리는 왜 *도메인 로직*이 아니라 *데이터베이스*가 아키텍처의 중심이 되게 만들고 있는가?

당신이 과거에 만들었던 유스케이스를 생각해봐라. 도메인 로직 혹은 영속성 계층 중 어느 것을 먼저 만들기 시작했는가? 대부분은 데이터베이스 구조를 만들고 그 위에다가 도메인 로직을 구현했을 것이다.

의존관계가 자연스럽게 흘러가기 때문에 전통적인 계층형 아키텍처에서는 타당한 방법이다. 그러나 비즈니스 관점에서는 절대적으로 옳지 않다. 그 어느것 보다 도메인 로직을 우선 만들어어야 한다. 그리고 나서야 제대로 이해했는지 알아낼 수 있다. 그리고 도메인 로직을 제대로 만들었다고 생각될때 영속성과 웹 레이어를 만들기 시작해야 한다.

데이터베이스 중심 아키텍처를 주도하는 힘은 ORM(Object Relational Mapping) 프레임워크다. 오해하지 마라. 난 이 프레임워크를 좋아하고 날마다 JPA와 Hibernate를 사용하고 있다.

그러나 ORM 프레임워크와 계층형 아키텍처를 결합한다면 비즈니스 규칙이 영속성 관점으로 쉽게 섞여버릴 수 있다.



<img src="chapter-01.assets/image-20201222072040297.png" alt="image-20201222072040297" style="zoom:67%;" />

[그림 1-2] 도메인 계층에서의 데이터베이스 엔티티 사용은 영속성 계층과의 강결합을 발생시킨다.



일반적으로, 위의 그림에서 나타난대로, 영속성 계층에 ORM에서 관리하는 엔터티를 가지고 있다. 계층은 하위 계층으로만 접근할 수 있기 때문에, 도메인 계층은 엔티티에 접근할 수 있다. 사용이 허용된다면 엔티티들은 사용될 것이다.

이것으로 인해 영속성 계층과 도메인 계층 사이의 강한 결합이 생긴다. 서비스는 비즈니스 모델로서 영속성 모델을 사용하고 도메인 로직을 처리할 뿐 아니라, eager/lazy loading, database transaction, flush cache, 유사한 내부 작업들도 사용할 것이다.

영속성 코드는 사실상 도메인 코드에 녹아들게 되며 서로 변경하기 어려워진다. 이것은 우리의 아키텍처의 목표가 되어야 할 유연성과 개방성과는 정반대 현상이 되는 것이다.



## It's Prone to Shortcuts

전통적인 계층형 아키텍처에서의 유일한 규칙은, 특정 계층에서는 동일 계층 혹은 그 하위 계층으로만 접근할 수 있다.

개발팀이 합의한 다른 규칙, 툴에 의해 강제될지도 모르지만 계층형 아키텍처 그 자체로는 어떤 규칙도 없다.

그래서, 계층형 아키텍처에서 상위의 어떤 컴포넌트에 접근이 필요하다면, 컴포넌트를 계층 하위에 내려서 문제를 해결할 수도 있다.

한번 정도는 괜찮지만 한번 한다는 것은 두번 할 수 있다는 여지를 남겨주는 것이다. 누군가 그렇게 할 수도 있다면 나도 할수 있지 않겠는가?

개발자로 그럼 shortcut을 가볍게 여긴다고 말하는 것은 아니다. 그렇게 할 여지가 있다면, 마감일이 다가오면 누군가는 그렇게 할 것이다. 전에 한 적이 있다면 누군가 다시 할 수 있다는 것이다. 이것이 "깨진 유리창 이론"이라고 하는 심리학적 효과이다 - 11장(Taling shortcuts Consciously)에서 추가 설명이 있다. 



<img src="chapter-01.assets/image-20201222073945165.png" alt="image-20201222073945165" style="zoom:67%;" />

[그림 1-3] 영속성 계층의 모두를 사용할 수 있기 때문에 시간이 지남에 따라 점점 비대해진다.



소프트웨어 프로젝트 개발과 유지보수 동안에, 영속성 계층은 위의 그림과 같이 될 가능성이 많다.

계층간에 컴포넌트 들을 바닥으로 배치함으로써 영속성 계층(일반 용어로, 최하단 계층)은 점점 비대해진다. 헬퍼나 유틸리티 컴포넌트는 어떤 계층에도 포함되지 않기 때문에 그럴 가능성이 가장 크다.

그럼, 아키텍처에서 "shortcut mode"를 사용하지 못하게 하려면, 적어도 추가적인 아키텍처 규칙을 강제하지 않고는 계층형이 최선의 선택이 아니다. 그리고 "강제"라는 말의 의미는 시니어 개발자가 코드리뷰를 하는 것을 말하는 것은 아니고 규칙 위반 시 빌드 실패를 할 수 있는 규칙을 의미하는 것이다.



## 테스트 하기 점점 어려워진다

> > > > > > > 여기부터 시작

레이어드 아키텍처의 일반적인 진화는 레이어는 <u>skipped된다는 것이다.</u> 웹 레이어에서 퍼시스턴시 레이어를 접근할 때 단일 엔티티를 조작하기 때문에 도메인 레이어를 거치지 않아도 된다는 말이지 않는가?



<img src="chapter-01.assets/image-20201222074953590.png" alt="image-20201222074953590" style="zoom:67%;" />

[그림 1.4] 도메인 레이어 <u>skip하는 것은</u> 코드상 도메인 로직이 흩어지는 경향이 있다.



<u>Again, this feels ok the first couple of times,</u> 그러나 종종 발생한다면 두가지 단점이 있다.

첫번째, 단일 필드를 조작할지라도 웹 레이어에서 도메인 로직을 구현하고 있다. 향후에 유스케이스가 확장되면 어떻게 할 것인가? 애플리케이션 전반적으로 책임과 필수 도메인 로직을 혼합하여 웹 레이어에 도메인 로직을 추가할 가능성이 많다.

두번째, 웹 레이어 테스트 관점에서, 도메인 레이어 뿐만 아니라 퍼시스턴시 레이어에 mock을 해야 한다. 이것은 단위테스트상 복잡성을 야기시킨다. 복잡한 테스트 준비과정이 첫번째 단계이다. 

웹 컴포넌트기 시간이 지남에 따라 점점 커짐으로써 다른 퍼시스턴시 컴포넌트의 의존성이 많아질 것이고 테스트 복잡성을 추가할 것이다. 어떤 관점에서는 실제 테스트 코드를 작성하는 것보다 의존성을 이해하고 mocking하는데 더 많은 시간이 걸릴 것이다.



## It Hides the Use Cases

개발자로써, 우리는 새로운 유스케이스를 구현하는 새로운 코드를 만들고 싶어한다. 그러나 새로운 코드를 작성하는 것보다 일반적으로 기존 코드 변경하는데 더 많은 시간이 소요된다. 이것은 지난 수년동안 작업해온 끔직한 레거시 프로젝트에 해당될 뿐 아니라 최초 개발이 진행된 신생 프로젝트에도 해당된다.

기능 추가 및 변경에 <u>적합한 장소를 찾기때문에</u> 아키텍처는 코드를 재빠르게 찾게 도움을 줄 수 있어야 한다. 계층형 아키텍처는 이것과 관련해서 <u>어떻게 유지되고 있어야 할까?</u>

<u>이미 논의된 대로, 계층형 아키텍처에서 도메인 로직은 계층 간에 쉽게  흩어질 수 있다. 사용하기 쉬운 케이스에 도메인 로직을 간과한다면 웹 레이어에 존재할 지도 모르겠다. 그리고 어떤 컴포넌트를 도메인과 퍼시스턴시 레이어에서 쉽게 접근된다면 퍼시스턴시 레이어에 있을지도 모르겠다.</u> 이것은 이미 새 기능 추가를 힘들게 하는 요인이다.

<u>더한 것이 있다</u>. 레이어드 아키텍처는 도메인 서비스의 범위에 어떤 규칙을 제약하지 않는다. 시간이 지남에 따라, 아래 그림에서 나타낸대로 다양한 케이스를 처리할 수 있는 폭넒은 서비스가 될 수 있다.



<img src="chapter-01.assets/image-20201222210312642.png" alt="image-20201222210312642" style="zoom:67%;" />

[그림 1.5] 넓은 범위의 서비스는 코드에서 특정 유스 케이스를 찾기 어렵다



넓은 범위의 서비스는 퍼시스턴스 레이어에서 많은 의존성을 가지고  그것을 의존하는 웹 페이어에 많은 컴포넌트를 가지게 된다. 또한 서비스 테스트를 어렵게 할 뿐더러 작업하는 유스케이스에 해당되는 서비스를 찾기도 어렵게 된다.

만일 도메인 서비스를 하나의 유스케이스만 처리하도록 범위를 좁힌다면 얼마나 사용하기 쉬울까? UserService에서 사용자 등록 유스케이스를 찾는 대신에 단지 RegisterUserService를 찾아서 작업할 것이다.



## It Makes Parallel Work Difficult

일반적으로 경영진들은 특정 날짜에 소프트웨어가 완료되기를 기대한다. 실제로, 특정 예산범위 내에서 완료되길 기대하지만 <u>문제를 복잡하게 하지 않는다.</u>

소프트웨어 개발자로의 경력에서 완료된 소프트웨어를 본적이 없다는 사실은 제쳐두더라도 일반적으로 특정일에 완료된다는 것은 병렬로 작업이 진행되어야 한다는 것을 의미한다.

아마 이 책을 읽지 않았어도 "Man-Month의 미신"이라는 명언을 알고 있을 것이다.

>  "뒤처진 소프트웨어 프로젝트에 인력을 투입하는 것은 프로젝트를 더 늦게 만드는 것이다"  - The Mythical Man-Month:

뒤처지지 않은 프로젝트에서는 어느 정도는 사실이다. 50명의 개발자 그룹이 10명의 개발자의 5배가 될거라도 기대해서는 안된다. 대규모 애플리케이션으로 작업하고 있고 하위 팀으로 나누고 소프트웨어를 세부화해서 작업한다면 가능할지도 모르겠지만 대부분의 경우는 <u>stand on each others's feet할 것이다.</u>

적절한 규모에서는 인력이 많으면 더 빠를 것이라고 기대할 수 있다. 경영진들이 우리에게 기다하는 것들이 바로 그것이다.

이 기대에 부응하기 위해 아키텍처는 병렬작업을 지원해야 한다. 이것은 쉬운 작업이 아니다. 레이어드 아키텍처는 실제 도움이 되지 않는다.

애플리케이션에 신규 기능을 추가한다고 생각해보자. 가용 인력 세 명의 개발자가 있다. 한명은 웹 레이어에 도메인 레이어에 한명, 세번째는 퍼시스턴스 레이어에 한명, 이렇게 피처를 추가할 수 있지 않을까?

레이어드 아키텍터에서는 그런 방식은 잘 되지 않는다. 퍼시스턴스 레이어상에서 모든 것이 빌드가 되므로 퍼시스턴스 레이어가 가장 먼저 개발되어야 한다. 그리고 나서 도메인 레이어, 그리고 웹 레이어 순으로 개발된다. 그래서 한명의 개발자만 동시에 피처를 개발할 수 있다.

그러나, 개발자들은 인터페이스를 먼저 정의할 수도 있고 각 개발자들은 실제 구현을 기다리지 않고 인터페이스로 작업을 진행할 수도 있다. 물론 가능하지만 앞에서 논의된 대로 데이터 주도 설계를 하고 있지 않다면 퍼시스턴스 로직은 도메인 로직과 복잡하게 엮여서 각각 관점에 맞게 작업이 불가능할 것이다.

코드 상에서 넓은 범위의 서비스가 있다면,  다른 피처를 병렬로 작업하는 것은 이미 힘들것이다. 또다른 유스케이스 작업은 동일 서비스가 병렬로 수정을 유발할 것이다. merge conflict를 유발하여 잠재적으로 퇴행이 될 것이다.



## How Does This Help Me Build Maintainable Software?

과거에 레이어드 아키텍처를 만들었다면 이 장에서 언급된 몇가지 단점과 관련이 있을 것이고 더 있을 수도 있다.

올바르게 작업이 진행되고 규칙들이 존재했다면 레이어드 아키텍처는 지속될 수 있을 것이다.

그러나, 여기서 말한 논의 내용은 레이어드 아키텍처가 잘못 되는 것들에 대해 이야기한다. 엄격한 자가 훈련 없이는 시간이 지남에 따라 유지될 수 없고 무너지기 쉽다. 매니저가 개발팀에게 개발 만기일로 압박하게 되면 이러한 자가 훈련은 느슨하게 될 수 밖에 없다.

레이어드 아키텍처의 함정을 생각해봄으로써 다음번 더 나은 지속가능한 솔루션의 해결책으로 논의할 때 도움이 될 것이다.  (레이어드 아키텍처이던 다른 아키텍처 스타일이던 상관없이)



































