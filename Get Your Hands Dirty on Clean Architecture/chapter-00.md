![Get Your Hands Dirty on Clean Architecture](chapter-00.assets/800x0.jpeg)















# Table of Contents







# > 서문



## 이 책에 대해서

우리는 적은 개발비용으로 쉽게 바꿀 수 있고 유연한 소프트웨어를 개발하고 싶을 것이다. 하지만, 부족한 개발 시간과 일시적인 미봉책 때문에 그러한 아키텍처를 만들기가 어렵다.

*Get Your Hands Dirty on Clean Architecture*는 전통적인 계층형 아키텍처 스타일과 그 단점에 대한 논의부터 시작한다. 또한 Robert C. Martin의 클린 아키텍처와 Alistair Cockburn의 헥사고날 아키텍처와 같은 도메인 중심 아키텍처 스타일의 장점에 대해서도 이야기한다. 그리고 나서, 헥사고날 아키텍처를 실제 코드로 나타내는 방법들을 각 장에서 직접 구현해 보는 것으로 이 책은 설명해 나간다. 헥사고날 아키텍처의 계층간 매핑 전략에 대한 세부내용을 배우게 될 것이며 아키텍처 요소들을 애플리케이션으로 어떻게 조합할 것인지에 대해서도 알게 될 것이다. 이 책 후반부에서는 아키텍처 경계를 강화하는 방법도 설명한다. 또한 일시적인 미봉책이 어떠한 유형의 기술 부채를 만들어내는지, 그러한 부채를 기꺼이 감수하는 것이 어떤 점에서 좋은지 배우게 될 것이다.

이 책을 읽은 후에, 웹 개발을 할 때 헥사고날 아키텍처를 사용하여 애플리케이션을 만드는데 필요한 모든 지식을 배우게 될 것이다.



## 저자에 대해서

**Tom Hombergs**는 여러 산업 분야의 많은 고객들을 위해서 다양한 소프트웨어 프로젝트를 수행한 10년 이상의 경험을 가진 직업과 열정을 가진 소프트웨어 엔지니어이다. 소프트웨어 프로젝트에서, 그는 Java 기술분야의 소프트웨어 개발자, 아키텍트, 컨설턴트 역할을 수행한다. 그는 글쓰는 일이 학습하는데 최선의 방법이라고 알게 되었고 또한 복잡한 소프트웨어 세계의 구조에 도움이 되는 글을 작성하기 위해서 소프트웨어 개발에서 만나는 주제들을 깊이 파헤치는 것을 좋아한다. 그는 그의 블로그(http://reflectoring.io)에 규칙적으로 소프트웨어 개발관련 글을 작성하고 가끔 컨퍼런스에서 발표도 한다.



## 학습 목표

이 책을 다 읽고 나면 여러분들이 할 수 있는 일이다.

* 계층형 아키텍처를 사용할 때 발생하는 잠재적인 단점을 인지한다.
* 아키텍처의 경계를 강화하는 방법을 적용한다.
* 일시적인 미봉책이 소프트웨어 아키텍처에 어떻게 영향을 미치는지 알아낸다.
* 어떤 아키텍처 스타일을 언제 사용할지에 대해 자신 있게 말한다.
* 아키텍처에 따른 코드를 구조화한다.
* 아키텍처의 각 구성요소를 포함하는 다양한 유형의 테스트를 적용한다.



## 대상 독자

현재 만들고 있는 소프트웨어 아키텍처에 관심이 있다면 이 책은 여러분들을 위한 책이다. 이 책을 최대한 잘 활용하기 위해서는, 여러분들이 웹 개발 경험이 있어야 한다. 이 책의 코드 예제들은 Java로 작성이 되어 있다. 여러분들이 Java 개발자는 아니지만 다른 언어의 객체 지향 코드를 읽을 수만 있다면 아무 문제 없다. Java나 프레임워크의 세부사항이 필요한 곳에서는 자세하게 설명할 것이다.



## 접근 방법

이 책은 온라인 송금을 하는 "BuckPal"이라는 웹 애플리케이션 예제를 통해 모든 개념을 설명한다.

애플리케이션 코드 예제는 GitHub(https://github.com/thombergs/buckpal)에 있다. GitHub repository의 issue에다가 어떤 질문이나 제안을 자유롭게 해도 된다.



## 표기법

이 책의 코드 예제는 Java로 작성되어 있다. Java 신봉자이긴 하지만, Java가 매우 장황한 프로그램 언어라는 것은 인정한다. 나는 여러분들이 코드 예제 내의 보일러 플레이트 코드에 주위가 흩트려지지 않기 위해서, 나는 그래도 두기로 결정했다. 코드가 여전히 유효하다면, 특정 코드를 자동생성하는 Lombok(https://projectlombok.org) 어노테이션을 코드 내에 포함했다.

* **@Getter** 어노테이션은 어노테이션이 달린 필드에 getter 메서드를 자동으로 만든다. 만일 클래스에서 사용된다면, 모든 private 필드를 대상으로 만든다.
* **@RequiredArgsConstructor** 어노테이션은 클래스의 private final 필드를 초기화하는 파라미터를 가진 생성자를 자동으로 만든다.
* **@NoArgsConstructor** 어노테이션은 인자가 없는 기본 생성자를 자동으로 생성한다.



## 피드백

여러분들이 이 책에 대해서 말하고 싶은 것이 있다면, 언제든지 환영한다. tom@relectoring.io로 메일로 연락을 해도 되고 트위터(https://twitter.com/TomHombergs)를 통해서 해도 된다.





