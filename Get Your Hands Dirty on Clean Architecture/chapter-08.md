# 8 Mapping Between Boundaries

이전 장에서 웹, 애플리케이션, 도메인, 영속성 레이어, 그리고 유스케이스 구현에 필요한 레이어에 대해 논의했다.

그러나 각 레이어 모델 사이에 끔찍하고 어디에나 있는 매핑 문제에 대해서는 아직 다루지 않았다. 나는 매퍼 구현을 하지 않기 위해 두 레이어에서 같은 모델을 사용할지에 대해 어떤 관점에서는 논의했다.

논쟁은 이같이 되었을 것이다.

###### Pro-Mapping Devleoper:

레이어사이에 매핑하지 않는다면 레이어 간 강결합되어 있는 양쪽 레이어에서 동일 모델을 사용해야 한다.

###### Contra-Mapping Developer

레이어 사이에 매핍을 사용한다면 CRUD를 하고 있고 레이어 사이에 동일 모델을 가지고 있기 때문에 유스케이스에서 지나칠 만큼 많은 코드를 만들어낸다.

이같은 논의에서 종종 있듯이, 이런 논쟁에는 양쪽에 진실이 있다. 매핑 전략에 장단점을 논의해보고 개발자들의 결정에 도움이 될만한 것을 알아보자.



## The "No Mapping" Strategy

첫번째 전략은 실제 전혀 매핑하지 않는 것이다.

<img src="chapter-08.assets/image-20201226212724481.png" alt="image-20201226212724481" style="zoom:67%;" />

[그림 8.1] 포트 인터페이스가 입출력 모델로서 도메인 모델을 사용한다면 레이어간 매핑이 필요없다.

위의 그림은 BuckPal 예제 애플리케이션의 "Send Money" 유스케이스와 관련있는 컴포넌트를 보여준다.

웹 레이어에서 웹 컨트롤러는 유스케이스를 실행하기 위해 SendMoneyUseCase 인터페이스를 호출한다. 이 인터페이스는 Account 객체를 인자로 받는다. 웹 레이어와 애플리케이션 레이어 양쪽이 Account 클래스(양쪽 모두 같은 모델을 사용)가 필요하다는 것을 의미한다. 

애플리케이션 반대 쪽에서는 영속성과 <u>애플리케이션 레이어 간 동일 관계가 있다.</u> 모든 레이어가 동일 모델을 사용하기 때문에 그들 사이 매핑을 구현할 필요가 없다.

이런 설계 방식의 영향도는 어떨까?

웹과 영속성 레이어는 모델상 특별한 요구사항이 있다. 웹 레이어가 REST를 경유하여 모델을 노출할 때 모델클래스는 JSON으로 직렬화 하는 방법을 정의하는 어떤 어노테이션이 필요할 지도 모른다. 데이터베이스 매핑을 정의하는 어노테이션이 필요한 ORM 프레임워크를 사용한다면 영속성 레이어에서는 맏을지도 모른다.

예제에서 모든 요구사항들이 도메인과 애플리케이션 레이어는 관련이 없더라도 Account 도메인 모델 클래스에서 처리되어야 한다. Account 클래스가 웹, 애플리케이션 그리고 영속성 레이어에 관련변 이유로 변화되어야 하기 때문에 단일 책임 원칙을 위반한다.

기술적인 요구사항과는 별개로 각 레이어는 Account 클래스에서 특정 필드가 필요할 수도 있다. 이것은 하나의 레이어만 적당한 특정 필드를 가진 조각난 도메인 모델이 될 수도 있다.

"No Mapping" 전략을 구현하지 않아야 한다는 말인가? 그렇지는 않다.

기분 나쁘게 들릴지는 몰라도 "No Mapping" 전략이 완벽한 해결책 일 수도 있다.

단순 CRUD 유스케이스를 생각해보라. 웹 모델을 도메인 모델로, 도메인 모델을 영속성 모델로 매핑할 필요가 있는가? 나는 그렇지 않다고 본다.

도메인 모델에 JSON이나 ORM 어노테이션은 어떠한가? 실제로 <u>bother us?</u> 어노테이션을 변경해야만 하거나 영속성 레이어의 변화가 있다면 도메인 모델 두개를 변경해야 한다면 어떤가?

모든 레이어는 같은 구조에서는 같은 정보를 필요하기 때문에 "No Mapping" 전략은 완전히 유효한 옵션이다.

그러나, 애플리케이션이나 도메인 레이어에서 웹이나 영속성 이슈를 처리하자마자 다른 매핑 전략으로 변경해야만 한다.

여기에 두명의 개발자의 대한 교훈이 있다. 과거에 매핑전략을 정했어도 나중에 바꿀 수 있다.

내 경험상 많은 유스케이스는 단순 CRUD 유스케이스로 시작한다. 나중에는 보다 값 비싼 매핑전략을 가질 많큼의 풍부한 행위와 검증을 가진 비즈니스 유스케이스로 성장한다. 혹은 다른 매핑 전략을 조사하지 않아서 CRUD 상태로 남겨둘 수도 있다.



## The "Two-Way" Mapping Strategy

각 레이어가 자신만의 모델을 가져야 한다는 매핑 전략을 "two-way" 매핑 전략이라고 부르고 다음 그림에 표시했다.

<img src="chapter-08.assets/image-20201226215105461.png" alt="image-20201226215105461" style="zoom:67%;" />

[그림 8.2] 각 어댑터는 자신의 모델을 가지고 있고 그 어댑터는 도메인 모델 전후의 매핑에 책임이 있다.

웹 레이어가 웹 모델을 내부 포트에서 필요로 하는 도메인 모델로 매핑한다. 또한 내부 포트로 리턴되는 도메인 모델 객체를 웹 모델로 매핑한다.

영속성 레이어는 외부 포트에서 사용되는 도메인 모델과 영속성 모델 사이의 매핑에 책임이 있다.

양쪽 레이어가 양방향에서 매핑되어서 그 이름을 "two-way" 매핑이라고 한다.

각 레이어는 자신만의 모델이 있고 각 레이어는 다른 레이어에 영향을 주지 않고(내용이 수정되지 않는 한) 자신의 모델을 수정할 수 있다. 웹 모델은 데이터의 최적의 출력를 가질 수 있다. 도메인 모델은 유스케이스를 구현하는데 최적의 구조를 가질 수 있다. 영속성 모델은 객체를 데이터베이스에 저장하는 데 ORM에서 필요로 하는 구조를 가질 수 있다.

이 매핑 전략은 웹이나 영속성의 관심사에 의해 오염되지 않는 클린 도메인 모델을 만들게 해준다. JSON이나 ORM 매핑 어노테이션을 포함하지 않는다. 단일 책임 원칙도 준수한다.

"two-way" 매핑의 다른 장점은 "no mapping" 전략 다음으로 개념적으로 가장 단순한 매핑 전략이다. 매핑에 대한 책임이 분명하다. 외부 레이어/어댑터는 내부 레이어 모델을 매핑한다. 내부 레이어는 오직 자신의 모델만 알고 매핑대신 도메인 로직에만 집중할 수 있다.

모든 매핑 전략에 있듯이, "two-way" 매핑 또한 단점이 있다.

첫번째로, 많은 코드가 필요하다는 것이다. 코드양을 줄이는 많은 매핑 프레임워크를 사용하더라도 모델간의 매핑을 구현하는 것은 시간이 ㅁ낳이 걸리는 작업이다. 매핑 로직을 디버깅 하는 것이 힘들기 때문이다. 특시 매핑 프레임워크를 사용할 때 제네릭 코드와 리플렉션 뒤쪽에 동작하는 코드를 숨긴다.

다른 단점은 도메인 모델이 레이어 경계간 통신하는데 사용된다는 것이다. 내부 포트와 외부 포트는 입력 파라미터와 응답값으로 도메인 모델을 사용한다. 이것은 외부 레이어의 필요에 의해서 변화가 될때 취약하게 한다. 반명 도메인 로직의 필요로 인해서만 변하는 도메인 모델에서는 바람직하다.

"no mapping" 전략과 같이 "two-way" 전략은 만능 해결책이 아니다. 많은 프로젝트에서 이러한 종류의 매핑은 전체 코드에서 지켜야하는 신성한 법칙으로 여겨졌다. 심지어 가장 단순한 CRUD 유스케이스에서 조차도 그러했다. 이것은 불필요하게 개발속도를 늦춘다.

매핑 없는 전략은 철칙으로 여겨서는 안된다. 대신 각 유스케이스별로 결정되어야 한다.



## The "Full" Mapping Strategy



























