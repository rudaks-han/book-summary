# 11. 의도적인 응급처치

이 책의 서두에서 기술부채만 쌓여 수정하지 못하고 항상 임시방편으로 처리할 수밖에 없는 상황에 대해 이야기했다.

임시방편으로 처리하지 않기 위해서 우리는 그 내용을 인지하고 있어야 한다. 그래서 이 장의 목표는 잠재가능성이 있는 임시방편식의 처리방법에 대한 의식을 높이고 그 효과를 논의해보는 것이다.

이러한 정보를 통해서 우연히 발생하는 임시방편식의 처리를 인지하고 고쳐 나갈 수 있다. 혹은 그럴수 밖에 없는 경우라면, 우리는 임시방편식 작업을 의식적으로 선택할 수도 있다. 

건축공학 책이나 혹은 더 끔찍하겠지만 항공기술관련 책에서 이런 임시방편식 작업이 있다고 생각해보자. 하지만 우리 대부분은 고층건물 혹은 항공기 관련 소프트웨어를 만들지는 않는다. 소프트웨어는 하드웨어보다 더 부드러워야 하고 변경이 쉬워야 한다. 그래서 우선 임시방편으로 처리하고 나중에(결코 하지 않겠지만) 수정하는 것이 더 경제적일 수도 있다.



## 임시방편 작업이 깨진 유리창과 같은 이유

1969년에 심리학자 Philip Zimbardo는 하나의 실험을 진행했고 그 이후에 깨진 유리창 이론(https://www.theatlantic.com/ideastour/archive/windows.html)으로 알려지게 되었다.

그는 번호판 없는 자동차 한대를 브론스 근처에 주차했고 더 생활권이 좋다고 알려진 팔로 알토에 또 다른 한대를 주차했다. 그리고 기다렸다.

브론스에 있는 차는 24시간만에 귀중품이 전부 도난되었고 지나가는 사람들이 그 차를 닥치는 대로 부수기 시작했다. 

팔로 알토에 있는 차는 일주일 동안 아무도 건드리지 않았서 Zimbardo가 창문 하나를 깨뜨렸다. 그때 부터 차는 브론스에 있는 차와 비슷하게 되었고 지나가는 사람들에 의해 금방 부서졌다.

차의 물건을 훔치거나 부수는 사람들은 모두 사회 계층 사람들이고 법을 준수하는 선량한 시민들이었다.

이런 인간의 행동은 깨진 유리창 법칙 이론으로 알려져 있다. 

> 파손되고 훼손되거나 버려진 어떤 것이 있다면 사람의 뇌는 더 부수고 훼손되게 한다.



이 이론은 삶의 많은 영역에 적용된다.

* 반달리즘(공공 기물 파손)이 흔한 곳에서 내버려진 차를 훼손하거나 파손하는 한계점은 낮아진다.
* 차의 창문이 깨졌다면 좋은 장소에 있더라도 더 훼손될 가능성은 높아진다.
* 청결하지 못한 침실에서 옷장에 옷을 넣을 가능성은 낮아진다.
* 왕따가 많은 그룹내에서는 사람들을 괴롭힐 가능성은 높아진다.



코드에 적용해보면 이러하다.

* 낮은 품질의 코드로 작업할 때 더 낮은 품질의 코드를 추가할 가능성이 높아진다.
* 위반사항이 많은 코드로 작업할 때 추가되는 코드의 위반사항도 많아진다.
* 임시방편 로직이 많은 코드로 작업할 때 임시방편 코드가 추가될 가능성은 높아진다.



이런 내용을 생각해볼때, 소위 "레거시"라고 불리는 코드 품질이 시간이 지남에 따라 더 나빠진다는 사실이 놀랍지 않은가?



## 클린(Clean)하게 시작해야 할 책임

코딩하는 것이 차를 부수는 것과 같지는 않지만 우리는 깨진 유리창 이론을 무의식적으로 실행하기 쉽다. 임시방편 작업 줄이고 최소한의 기술 부채로 프로젝트를 깨끗하게 시작하는 것이 중요하다. 임시방편 작업이 슬며시 생기면 깨진 유리창처럼 동작하며 더 많은 임시방편 작업을 유발한다.

소프트웨어 프로젝트는 많은 비용과 오랫동안의 노력이 필요하기 때문에, 깨진 유리창을 계속 가지고 있는 것은 소프트웨어 개발자로서 더 많은 책임감을 느끼게 한다. 우리는 프로젝트를 완료하지 못하고 다른 누군가에게 넘겨줘야 할 수도 있다. 그들에게는 이런 내용은 전혀 관련이 없을 뿐더러, 깨진 유리창을 더욱 더 만들게 한다.

그러나 작업하는 코드가 크게 중요하지 않거나 프로토타이핑이나 경제적인 이유로 임시방편으로 작업하는 경우도 있다.

그렇게 의식적으로 추가된 임시방편 작업은 해당 내용을 문서화하는데 신경써야 한다. 이는 Michael Nygard가 그의 블로그(http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions)에서 제안한 Architecture Decision Records(ADRs) 공식문서에서 볼 수 있다. 우리 자신과 후임자에 빚지고 있는 것이다. 팀의 모든 구성원이 이 문서를 알고 있다면, 팀 구성원 모두가 임시방편 작업은 의도적이고 긍정적인 이유로 해야 한다고 알고 있기 때문에 깨진 유리창 효과는 줄어들 것이다.

다음 내용은 이 책의 나타난 헥사고날 아키텍처의 임시방편 작업이라고 생각되는 패턴을 살펴볼 것이다. 임시방편 작업의 효과와 논쟁거리, 그 내용에 대한 다양한 의견들을 살펴볼 것이다.



## 유스케이스간의 모델 공유

*4장(Implementing a Use Case)*에서 각 유스케이스에서는 각각의 입/출력 모델을 가져야 한다고 이야기했다. 이는 입력 파라미터 유형과 리턴값의 유형은 다르게 사용되어야 한다는 것을 의미한다.

다음 그림은 동일 입력 모델을 공유하는 두 개의 유스케이스의 예를 보여준다.



<img src="chapter-11.assets/image-20210112185856753.png" alt="image-20210112185856753" style="zoom:67%;" />

[그림 11.1] 유스케이스 간 입/출력 모델을 공유하는 것은 유스케이스 사이의 결합도를 높인다.



이 상황에서 모델을 공유함으로써 발생되는 영향도는 **SendMoneyUseCase**와 **RevokeActivityUseCase**가 서로 결합된다는 것을 나타낸다. **SendMoneyCommand** 클래스를 수정하면 양쪽 케이스 모두 영향받는다. 단일 책임 원칙에 의해 변경해야 할 이유를 공유한다. 양쪽 유스케이스가 동일 출력모델을 공유할 때도 동일하다.

유스케이스 간 입/출력 모델을 공유하는 것은 각 유스케이스가 기능적으로 경계가 구분된다면 가능하다. 즉, 어떤 요구사항을 공유하는 경우라면. 이 경우에는 *특정 부분을 수정하면 실제 양쪽 유스케이스가 영향을 받는다.*

두 개의 유스케이스가 서로 독립적으로 변경되어야 한다면, 이것은 잘못된 방법이다. 코드를 처음 작성할 때는 같은 것처럼 보여서 이것이 입/출력 클래스를 중복처럼 느껴질지 모르겠지만 이런 경우에는 시작할 때 부터 유스케이스를 분리해야만 한다.

그래서 비슷한 개념의 여러 유스케이스를 만들 때, 유스케이스가 각각 다르게 변경될 것인지에 대해 주기적으로 의문을 제기하는 습관을 길러야 한다. "그렇다"라면 입/출력 모델을 분리해야할 시기가 온 것이다.



## 입/출력 모델로써 도메인 엔티티 사용하기

> > > 여기

**Account** 도메인 엔티티가 있고 입력 포트(**SendMoneyUseCase**)가 있다면, 다음 그림에 나타낸대로 입력포트의 입/출력 모델로서 엔티티를 사용하기 쉽다.



<img src="chapter-11.assets/image-20210112185905529.png" alt="image-20210112185905529" style="zoom:67%;" />

[그림 11.2] 유스케이스의 입/출력 모델로서 도메인 엔티티를 사용하는 것은 도메인 엔티티를 유스케이스와의 결합도를 높인다.



인바운드 포트는 도메인 엔티티를 의존한다. 이런 작업의 결과는 **Account** 엔티티의 변경의 또 다른 이유를 추가했다는 것을 의미한다.

잠깐, **Account** 엔티티는 **SendMoneyUseCase** 입력 포트에 의존을 가지고 있지 않고 입력 포트가 어떻게 엔티티의 변경 이유가 될 수 있을까?

**Account** 엔티티에서 현재 사용할 수 없는 유스케이스의 계좌에 대한 정보가 필요하다고 해보자. 이 정보는 **Account** 엔티티에 저장되지 않고 다른 도메인 혹은 바운디드 컨텍스트에 저장된다. 그럼에도 불구하고 유스케이스 인터페이스에서 이미 사용할수 있기 때문에 **Account** 엔티티에 새 필드를 추가하기 쉽다.

단순 생성 및 수정 유스케이스에서 유스케이스 인터페이스의 도메인 엔티티는 더 쪼개질 수 있다. 엔티티는 정확한 정보를 포함하기 때문에 데이터베이스에 상태를 저장할 필요가 있다.

유스케이스가 단순히 데이터베이스 몇개 필드를 수정하는 것이 아니고 좀 더 복잡한 도메인 로직을 구현하는 것이라면, 유스케이스 인터페이스의 전용 입/출력 모델을 사용해야 한다. 왜냐하면 유스케이스의 변화가 도메인 엔티티에 영향을 주기를 원하지 않기 때문이다.

이러한 응급처치가 위험한 것은 많은 유스케이스가 단순 생성, 수정 유스케이스로 시작해서 시간이 지남에 따라 복잡한 도메인 로직 덩어리가 될 가능성이 높다는 사실이다. 특히 MVP(minimum viable product)로 시작하고 점진적으로 기능을 추가하는 애자일 환경에서 특히 그렇다. 만일 시작할 때 입력 모델로서 도메인 엔티티를 사용했다면 도메인 엔티티와 무관한 전용 입력모델로 바꿔야 할 시기를 찾아야 한다.



## 인바운드 포트 생략하기

아웃바운드 포트가 애플리케이션 계층과 아웃바운드 어댑터 간의 의존성 역전에 필요하지만, 의존성 역전에 인바운드 포트를 사용할 필요는 없다. 다른 그림에 나타낸 대로 인바운드 포트 없이 인바운드 어댑터가 애플리케이션 서비스를 직접 접근하도록 할 수 있다.



<img src="chapter-11.assets/image-20210112185916648.png" alt="image-20210112185916648" style="zoom:67%;" />

[그림 11.3] 입력 포트가 없다면 도메인 로직으로 진입점을 잃어버리게 된다.



인바운드 포트를 제거함으로써 인바운드 어댑터와 애플리케이션 계층 사이의 추상화 계층을 줄였다. 추상화 계층을 제거하는 것이 보통은 더 좋아 보인다.

그러나 인바운드 포트는 애플리케이션 내부로의 진입점을 의미한다. 포트를 제거하면 어떤 유스케이스를 구현하기 위해 호출할 수 있는 서비스 메서드를 찾아내기 위해 애플리케이션 내부에 대해 더 많이 알아야 한다. 전용 입력 포트를 유지함으로써, 애플리케이션의 진입점을 쉽게 확인할 수 있다. 코드의 흐름을 파악하려는 신입 개발자에게 특히 더 쉽다.

인바운드 포트를 유지하는 또 다른 이유는 아키텍처를 쉽게 강화하게 한다는 것이다. *10장(Enforcing Architecture Boundaries)*의 강화된 옵션으로, 인바운드 어댑터가 애플리케이션 서비스가 아닌 오직 입력 포트를 호출할 수 있게 한다. 이것은 애플리케이션 계층으로 향하는 모든 진입점을 의식적으로 표시 한다. 인바운드 어댑터에서 호출될 의도가 아닌 메서드를 서비스 내에서 실수로 호출할 수는 없을 것이다.

애플리케이션이 매우 작고 단일 인바운드 어댑터만을 가지고 있어서 인바운드 포트의 도움 없이 제어 흐름을 이해할 수 있다면, 인바운드 포트 없이 할 수 있을 것이다. 그러나 애플리케이션이 계속 작게 유지되고 지속적으로 단일 인바운드 어댑터만을 가질 것이라고 이야기 하는 일이 얼마나 많이 있을까?



## 애플리케이션 서비스 생략하기

다음 그림에서 나타낸대로 인바운드 포트와는 별개로 어떤 유스케이스에서는 전체로써 애플리케이션 계층을 생략할 수도 있을 것이다.



<img src="chapter-11.assets/image-20210112185927061.png" alt="image-20210112185927061" style="zoom:67%;" />

[그림 11.4] 애플리케이션 서비스가 없다면 도메인 로직을 둘 적당한 위치가 없다.



여기서 아웃바운드 어댑터 내의 **AccountPersistenceAdapter** 클래스가 직접 인바운드 포트를 구현하고 입력 포트를 구현하는 애플리케이션 서비스를 대체할 수 있다.

이 상황에서 애플리케이션 서비스는 보통 어떤 도메인 로직도 추가하지 않고 영속성 어댑터로의 생성, 수정, 삭제만 전송하기 때문에 단순 CRUD 유스케이스에서는 이렇게 하기 쉽다. 전송하는 대신 영속성 어댑터가 직접 유스케이스를 구현하게 할 수 있다.

그러나, 이것은 인바운드 어댑터와 아웃바운드 어댑터 사이에 Account 도메인 엔티티의 공유 모델이 필요하다. 그래서 도메인 모델을 이전에 나타낸 것과 같이 입력 모델로 사용하고 있다는 것을 의미한다.

게다가, 애플리케이션 내부 유스케이스를 더 이상 나타내지 않는다. CRUD 유스케이스가 시간이 지남에 따라 더 복잡해진다면 유스케이스가 여기서 구현되었기 때문에 아웃바운드 어댑터로 직접 도메인 로직을 추가하기 쉽다. 이것은 도메인 로직을 분산하게 만들고 찾기 힘들어지고 유지보수 하기도 힘들어진다.

결국 서비스를 관통하는 <u>보일러플레이트를</u> 방지하기 위해 결국 단순 CRUD 유스케이스에 애플리케이션 서비스를 건너뛸 수도 있을지도 모른다. 그러나 팀은 엔티티를 생성, 수정, 삭제 작업 이상을 하는 유스케이스에 대해서 애플리케이션 서비스를 도입하는 명확한 가이드를 개발해야만 한다.



## How Does This Help Me Build Maintainable Software?

응급처치가 경제적인 관점에는 의미가 있을 수도 있다. 이 장은 응급처치가 도움이 될지를 결정하는데 몇 가지 인사이트를 제공한다.

여기에서의 논의는 단순 CRUD 유스케이스를 위해 전체 아키텍처를 구현하는 건 과다하다고 느낄 수 있기 때문에 응급처치를 도입하기 쉽다는 것을 보여준다. 모든 애플리케이션이 처음에는 작게 시작하기 때문에, 유스케이스가 CRUD상태로 시작할 때 팀의 합의가 필요하다는 것은 매우 중요하다. 결국에는 팀이 응급처치를 유지보수가 용이한 아키텍처로 대체할 수 있다.

어떤 유스케이스는 단순 CRUD 상태만 필요하다. 유지보수의 비용이 많이 들지 않기 때문에 결국 응급처치를 적절하게 유지하는 것이 좋다.

어떤 경우에는 미래 결정을 재평가할 수 있도록 응급처치를 선택한 아키텍처와 결정사항을 문서화 해야 한다.



