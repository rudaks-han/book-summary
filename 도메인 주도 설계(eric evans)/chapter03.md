# 03 모델과 구현의 연계

###### 프로젝트 일화

* 문열고 들어갔을 때 보이는 것은 전체 클래스 다이어그램이었다.
* 사람들이 전체 모델을 심층적으로 조사하고 개발하는데 수개월을 보낸 첫날이었다.
* 모델내의 객체는 서너개의 다른 객체오 복잡한 연관관계를 맺고 있었고 거미줄 같은 관계를 구분하는 경계가 거의 없었다.
* 분석가는 도메인의 특성에만 충실했던 것이었다.
* 얼마 간의 연구 끝에 꽤 많은 것을 배울 수 있었다.
* 하지만 이렇게 학습한 내용이 애플리케이션 코드와 설계에 어떠한 통찰력도 줄 수 없다는 점이었다.
* 애플리케이션 구현이 시작했을 때 개발자는 얽혀있는 연관관계를 트랜잭션 무결성을 준수하면서 저장 및 조회 가능한 단위로 해석할 수 없다는 사실을 금방 깨달았다.
* 객체 데이터베이스를 사용하고 있어서 관계형 테이블 매핑이 필요 없었다.
* 기술 분석가와 업무 전문가의 관점에서는 옳은 것이었지만 구현 과정의 시행착오가 포함되지 않은 개념에 근거한 객체라서 개발자는 활용할 수 없다.
* 개발자는 기조 모델에 근거하지 않고 개발을 진행했다.
* 프로젝트에 도메인 모델은 있었지만 동작하는 소프트웨어를 개발하는 데 직접적으로 도움을 주지 않는 한 종이에 기록된 모델이 무슨 의미가 있겠는가?



## MODEL-DRIVEN DESIGN (모델 주도 설계)

도메인 모델의 부재

* 도메인 모델은 전혀 없고 기능만 차례로 구현하기 위해 코드를 작성하는 프로젝트에서는 지식 탐구와 의사소통의 이점을 거의 살리지 못한다. 도메인이 복잡하다면 이러한 프로젝트는 난관에 처할 것이다.

* 도메인 모델을 시도하더라도 모델과 코드를 긴밀하게 연결하지는 못한다. 처음에는 유용할지는 모르지만 모델은 점차 관련성이 떨어진다.



분석 모델

* 모델과 코드 간의 연결이 끊어지는 경우는 다양하고 의도적으로 그렇게 할 때도 있다.
* 분석 모델은 설계와 뚜렷이 구분되고 보통 다른 사람이 만든다.
* 분석 모델이라고 하는 이유는 분석 모델이 소프트웨어 시스템에서 수행할 역할에 대해서는 전혀 고려하지 않은 채 업무 도메인의 개념만을 쳬게화하고자 해당 업무 도메인을 분석한 결과물이기 때문이다.
* 분석 모델은 오로지 <u>이해하기 위한 수단</u>으로만 간주된다.
* 순수하게 이론에만 치우친 분석 모델은 코딩이 시작되자마자 폐기되고 대부분의 문제를 다시 검토해야 한다. 



> 설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 안흔ㄴ다면 그 모델은 그다지 가치가 없으며 소프트웨어의 정확함도 의심스러워진다. 동시에 모델의 설계 기능 사이의 복잡한 대응은 이해하기 힘들고, 실제로 설계가 변경되면 유지보수가 불가능해진다. 분석과 설계가 치명적으로 동떨어지고, 그에 따라 각자의 활동에서 얻은 통찰력이 서로에게 전해지지 않는다.



MODEL-DRIVEN DESIGN

* MODEL-DRIVEN DESIGN에서는 양쪽 모두의 목적을 달성하는 단일 모델을 찾기 위해 분석모델과 설계를 나누는 이분법은 채택하지 않는다.
* 순수하게 <u>기술적인 쟁점은 배제</u>하고 각 객체는 모델에서 기술한 개념적 열할을 수행하게 된다.



> 소프트웨어 시스템의 일부를 설계할 때는 도메인 모델을 있는 그대로 반영해서 설계와 모델의 대응을 분명하게 하라.
>
> 모델로부터 설계와 기본적인 책임 할당에 사용한 용어를 도출하라. 코드를 작성할 때 그러한 용어를 사용하면 코드가 모델을 표현한 것이 되고, 코드의 변경이 곧 모델의 변경으로 이어질 수 있다.
>
> 구현을 모델과 묶으려면 보통 객체지향 프로그래밍과 같은 모델링 패러다임을 지원하는 언어가 필요하다.



### 모델링 패러다임과 도구 지원

객체지향 프로그래밍은 모델링 패러다임을 근거하고 모델의 구성요소에 대한 구현을 제공하기 때문에 매우 효과적이다.

<예제>



### 내부 드러내기: 왜 모델이 사용자에게 중요한가





## HANDS-ON MODELER (실천적 모델러)

모델과 코드의 구분

* 제조업은 소프트웨어 개발 분야에서 인기있는 은유이다.
* 고도의 숙련된 엔지니어는 설계를, 덜 숙련된 노동자는 제품을 조립한다는 것이다.
* '소프트웨어 개발은 모든 것이 설계다'란 한가지 단순한 이유로 많은 프로젝트를 엉망으로 만들었다. 
* <u>분석과 모델링, 설계, 프로그래밍의 책임을 지나치게 구분하는 것은 MODEL DRIVEN DESIGN과 상충한다.</u>
* 관리조직에서는 모델러는 모델링을 해야 하고, 코드를 작성하는 것은 시간 낭비라고 생각하는 경향이 있다.



문제점

* 모델의 구현과 기술과의 상호작용에 대한 피드백이 간접적이었다는 것이다.
* 모델의 어떤 측면은 우리가 사용하는 기술 플랫폼에서 매우 비효율적인 것으로 밝혀졌는데, 몇달동안 그 의미를 파악하지 못했다.
* 개발자들은 상아탑에만 머물러 있는 아키텍트의 지시를 받는 위험을 더는 감수할 수 없었다.



> 코드를 작성하는 사람이 모델에 책임을 느끼지 못하거나 애플리케이션을 대상으로 모델이 동작하게 만드는 법을 모른다면 그 모델은 소프트웨어와 무관해진다. 코드의 변경이 곧 모델의 변경이라는 점을 개발자가 인식하지 못하면 리팩터링은 모델을 강화하기보다는 약화시킬 것이다.
>
> 설계자가 구현을 하지 못해 개발자와 업무 단절이 생기면 숙련된 설계자의 지식과 솜씨는 결코 다른 개발자에게 전해지지 못할 것이다.



