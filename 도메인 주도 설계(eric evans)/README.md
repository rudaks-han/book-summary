# 제1부 동작하는 도메인 모델 만들기

![image-20210218200646548](chapter01.assets/image-20210218200646548.png)



18세기 중국 지도. 중국의 사회상에 맞게 세계를 모델화한 것이고 중국에 초점을 맞췄다. 다른 나라를 이해하는 데는 도움이 되지 못하고 오늘날 중국의 모습과도 전혀 맞지 않다.

지도는 모델이며, 모든 모델은 중요한 사실이나 사상의 일부 측면을 나타낸다. `모델은 대상을 단순화한 것`이다. 즉, 모델은 어떤 사실을 해석한 것으로 볼 수 있고, 당면한 문제를 해결하는 것과 관련된 측면을 추상화하고 <u>그 밖에 중요하지 않은 세부사항에는 주의를 기울이지 않는다</u>.

사용자의 활동에 도움이 되는 소프트웨어를 만들기 위해서 개발팀은 사용자의 활동과 관련된 지식체계에 집중해야 한다. 모델은 이러한 부담을 해소하기 위한 도구다. 모델은 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다.

도메인 모델링은 가능한 한 "사실적인" 모델을 만드는 문제가 아니다. 현실 세계에 실재하는 사물에 대한 도메인에서도 모델은 인위적 창조물이다. 그리고 단순한 결과를 내는 소프트웨어 매커니즘을 만드는 것도 아니다. 도메인 모델링은 어떤 목적에 따라 제약에 구애받지 않고 `현실을 표현하는 영화 제작`에 가깝다. 다큐멘터리 영화에서도 실생활을 편집해서 보여준다.



## 도메인 주도 설계에서의 모델의 유용성

1. **모델과 핵심 설계는 서로 영향을 주며 구체화된다. ** 모델이 프로그램에 적용되게끔 하는 것은 모델과 구현 간의 긴밀한 연결이다. 이러한 모델과 구현의 연결은 유지보수와 계속되는 기능 개선에도 도움이 되는데 그 이유는 <u>모델을 이해한 바에 근거해 코드를 해석</u>할 수 있기 때문이다.
2. **모델은 모든 팀 구성원이 사용하는 언어의 중추다**. 모델과 구현에서 사용하는 용어가 동일해야 한다.
3. **모델은 지식의 정수만을 뽑아낸 것이다.**  



## 소프트웨어의 본질

소프트웨어의 본질 = 도메인에 관련된 문제를 해결하는 능력

개발자는 이러한 문제를 해결하기 위해서 도메인 연구에 몰두해야 한다. 그뿐만 아니라 모델링 기법을 연마해서 도메인 설계에 통달해야 한다.

그러나 이러한 도메인 연구는 최우선 과제로 여겨지지 않는다.

**대부분 유능한 개발자** = 도메인을 학습하는 데 관심 없음. 도메인 모델링 기법을 쌓는데 전념하지 않음

**기술자들** = 자신의 기술력을 훈련할 수 있는 정략적인 문제를 좋아함. 도메인 업무는 무질서하고 개발자로서의 능력에 보탬이 될것 같지 않음

**기술적 재능이 있는 사람** = 정교한 프레임워크를 만드는 작업에 착수해 기술을 바탕으로 도메인 문제를 해결하려 함.



# 01 지식 탐구

## 효과적인 모델링의 요소

1. `모델과 구현의 연계`
2. 모델을 기반으로 하는 `언어 정제`
3. `풍부한 지식`이 담긴 모델 개발: 모델은 단순히 데이터 스키마가 아니라 복잡한 문제를 해결하는 데 필수불가결한 것이었다. 모델에는 다양한 지식이 포함돼 있었다.
4. `모델의 정제`. 모델에는 중요한 개념이 더해졌으며 쓸모없거나 중요하지 않다고 판명된 개념이 제거됐다는 점이 중요하다. 불필요한 개념과 필요한 개념이 한데 묶여 있을 경우 본질과 무관한 개념은 모두 제거할 수 있게 본질적인 개념만을 식별할 수 있는 새로운 모델을 고안해냈다.
5. 브레인스토밍과 실험. 스케치. 시나리오를 말로 표현해보기만 해도 타당성 여부를 재빨리 판단할 수 있다.



## 지식 탐구

재무 분석가는 숫자를 면밀하게 검토한다.

**도메인 모델링을 수행하는 사람들**

- 지식을 면밀하게 탐구한다.
- 엄청나게 많은 정보 속에서 미미한 관련성을 찾아낸다.
- 전체를 이해할 수 있는 간결한 관점을 찾아 체계적인 아이디어를 시도해본다.
- 수많은 모델이 시도,거부,변형된다.
- 세부사항에 맞는 추상적 개념이 나타나면 비로소 성공에 이른다.



**지식탐구 활동**

- 혼자서 하는 활동이 아니다.
- 개발자와 도메인 전문가로 구성된 팀이 협업
- 지식은 도메인 전문가의 머리속, 기존 시스템 사용자, 동일한 도메인에 관련된 레거시 시스템의 기술팀, 다른 프로젝트 경험에서 나온다.
- 지식은 문서의 형태를 띄며, 대화의 형태도 많다.



**폭포수 개발 방식**

- 업무 전문가가 분석가에서 설명하고 다시 분석가는 업무 전문가가 설명한 내용을 이해하고 추상화해서 소프트웨어를 코드로 작성하는 프로그래머에게 넘긴다. 
- 이런 접근법은 피드백이 전혀 없어서 실패하기 마련이다.
- 모델을 만드는 모든 책임은 분석가에게만 있다. 업무 전문가가 알려주는 사항에만 근거한다.
- 분석가들은 프로그래머에게서 배우는 기회를 얻지 못한다.
- 지식은 한 방향으로만 흘러갈 뿐 축적되지 않는다.



**지식 축적 실패**

- 개발자들은 원하는 기능을 전문가가 기술하게 하고 기능 구현을 시작
- 결과를 전문가에게 보여주고 다음 해야할 일을 정한다.
- 개발자가 도메인에 관심없다면 숨겨진 원리는 알지 못한채 애플리케이션에서 수행하는 일만 습득한다.



**훌륭한 프로그래머**

- 애초부터 추상화를 시작해서 좋은 모델로 발전시킬 것이다.
- 이런 과정이 도메인 전문가의 협업 없이 기술적인 측면에서 일어난다면 개념은 초보적인 수준에 머문다.



**팀 모델링**

- 지속적인 정체를 하는 개발자는 기능에만 머무르지 않고 업무의 중요 원칙들을 배운다.
- 모델은 명료하게 조직화, 추상화될 수 있으며 구현을 더 용이하게 만들어준다.
- 도메인 전문가의 지속적인 관여로 심층적인 업무 지식을 반영하고, 추상화된 개념은 업무 원칙에 해당한다.



## 지속적인 학습

소프트웨어 개발을 시작할 때 우리는 충분히 알지 못한 상태에서 시작한다. 지식은 단편적이고, 문서는 흩어져있고, 정말 필요한 지식이 어떤 것인지 알지 못한다. 기술적으로 어려워 보이지 않는데 힘든 경우가 있다. 우리는 스스로 얼마나 알지 못하는 가를 깨닫지 못한다.

**지식의 이동**

- 모든 프로젝트에서는 지식이 새기 마련
- 학습한 사람들은 계속 자리를 옮긴다.
- 조직 개편으로 팀이 흩어지고 지식도 다시 흩어진다.
- 중대한 하위 시스템은 외주 제작되어 코드는 전달되지만 지식은 전달되지 않는다.



지속적인 학습

- 생산성이 매우 뛰어난 팀은 지속적인 학습이 있어야 한다.
- 개발자에게 도메인 모델링 기술과 기술적 지식이 모두 향상된다는 것을 의미한다.
- 특정 도메인에 관해 진지하게 학습하는 것도 포함된다.



## 풍부한 지식이 담긴 설계

모델의 지식은 단순한 "명사 찾기" 이상이다. 엔티티만큼 업무 활동과 규칙도 도메인에 중요한데, 어떠한 도메인에도 다양한 범주의 개념이 존재한다. 지식탐구는 이러한 통찰력을 반영하는 모델을 만들어낸다.



예제) 감춰진 개념 추출하기

> 10% 초과예약 허용

```java
public int makeBooking(Cargo cargo, Voyage voyage) {
  double maxBooking = voyage.capacity() * 1.1;
  if ((voyage.bookedCargoSize() + cargo.size()) > maxBooking)
    return -1;
  ...
}
```

1. 코드가 작성된 대로라면 개발자의 도움이 있더라도 업무 전문가가 이 코드를 읽고 규칙을 검증하지는 못할 것이다.
2. 해당 업무에 종사하지 않고 기술적인 측면만 담당하는 사람은 코드와 요구사항을 결부시키기가 어려울 것이다.



초과예약 규칙 == 정책(policy)

새 Overbookng Policy(초과예약 정책) 클래스에는 아래 메서드가 포함된다.

```java
public boolean isAllowed(Cargo cargo, Voyage voyage) {
  return (cargo.size() + voyage.bookedCargoSize()) <= (voyage.capacity() * 1.1);
}
```



더 명시적인 설계는 아래와 같은 이점이 있다.

1. 초과예약의 특성을 단순한 계산에 불과한 것이 아니라 별개의 중요한 업무 규칙임을 알아야만 할 것이다.
2. 프로그래머는 업무 전문가에게 이해할 수 있는 수준에서 코드까지 보여줄 수 있고 피드백을 받을 수 있다.



## 심층 모델

지식 탐구는 탐험과도 같아서 어디서 끝나게 될지 알지 못한다.



# 02 의사소통과 언어 사용

**도메인 모델**

- 소프트웨어 프로젝트를 위한 **공통 언어**의 핵심
- **모델**은 프로젝트에 참여한 사람들의 머리속에 축적된 **개념**은 모아둔 것이고 도메인에 대한 통찰력을 반영하는 **용어**와 **관계**로 표현된다.
- 이러한 용어와 관계는 기술개발을 할 수 있을 만큼 충분히 정확하고 언어의 의미체계를 제공한다.
- 모델을 개발활동과 결부시키고 코드와 연계하는 데 매우 중요한 **연결고리** 역할을 한다.



> 프로젝트에서 언어를 사용하는 것은 미묘하지만 아주 중요하다.



## UBIQUITOUS LANGUAGE (보편 언어)



**도메인 전문가와 개발자의 사용언어 차이**

* **도메인 전문가**는 기술용어를 이해하는 데 한계가 있지만 자신의 **전문 용어**는 다양하게 사용한다.
* **개발자**는 **시스템 용어**를 서술하고 이해해도 전문자들의 언어의 의미는 알지 못한다.
* 개발자는 설계는 뒷받침하지만 도메인 전문가가 이해할 수 없는 방식으로 추상화할지도 모른다.
* 문제의 다양한 영역을 다루는 개발자는 자기만의 설계 개념과 도메인을 서술하는 방식을 고안해내기 마련이다.

* 도메인 전문가는 원하는 바를 모호하게 서술한다.
* 도메인을 이해하려고 노력하는 개발자가 이해하는 바도 모호한 수준에 머문다.
* 팀의 일부만이 가까스로 도메인 전문가와 개발자가 사용하는 언어를 모두 소화해 내지만, 금방 병목지점이 되고 반영하는 바도 정확하지 않다.



**공통언어의 부재**

* 공통언어가 없는 프로젝트는 개발자 = 도메인 전문가 간의 **번역이 필요**하다.
* 모델의 개념을 혼란스럽게 하는 번역은 **해로운 코드 리팩터링**으로 이어진다.
* 의사소통이 직접적으로 일어나지 않아 겉으로 드러나지 않는다.
* 용어를 다르게 써도 알아채지 못한다.
* 번역에 따르는 노력으로 지식과 아이디어 상호작용이 저해된다.



예제: 화물의 운송 항로 고안하기

<대화내용>



### 크게 소리내어 모델링하기

인간은 구어에 천부적인 재능이 있다. 하지만 대개 도메인 모델의 언어를 사용하지 않는다. 대부분 각자 생각하는 방식의 언어로 표현한다.



모델을 정제하는 가장 좋은 방식은 모델 요소를 말하기를 통해 살펴보는 것이다.

>"Routing Service에 출발지, 목적지, 도착 시각을 전달하면 화물이 멈춰야 할 지점을 찾고, 음... 그것을 데이터베이스에 삽입한다" `(모호하고 기술적인)`
>
>"출발지, 목적지, 등등... 이것들을 모두 Routing Service에 넣으면 필요한 것이 모두 담긴 Itenerary를 돌려받는다." `(좀더 완전해졌지만, 장황함)`
>
>"Routing Service는 Routing Specification을 만족하는 Itinerary를 찾는다." `(간결함)`



도메인 모델에 사용된 UBIQUITOUS LANGUAGE를 논의할 때 사용하면 우리는 해당 언어를 더욱 유창하게 구사하고 서로에게 해당 언어의 미묘한 차이까지 가르칠 수 있다.

UBIQUITOUS LANGUAGE 패턴의 추가사항은 다음과 같다.

> 시스템에 관해 이야기를 주고 받을 때 모델을 사용하라. 모델의 요소와 상호작용을 이용하고 모델이 허용하는 범위에 **개념**을 조합하면서 시나리오를 큰 소리로 말해보라. 표현해야 할 것을 더 **쉽게 말하는 방법**을 찾아낸 다음 그러한 새로운 아이디어를 **다이어그램과 코드**에 적용하라.



### 한 팀, 한 언어

종종 기술 담당자는 업무 전문가에게 도메인 모델을 보여줄 필요가 없다고 생각한다. 그들은 이렇게 말한다.

> "업무 전문가들에게는 너무 추상적이라서요"
>
> "업무 전문가들은 객체를 이해하지 못해요"
>
> "업무 전문가들이 쓰는 용어로 된 요구사항을 만들어야 해요"



모델의 핵심은 도메인 전문가의 관심을 끌어야 한다.

* 설계에는 도메인 전문가와 관련이 없는 기술적인 구성요소도 있지만 <u>모델의 핵심은 도메인 전문가의 관심을 끌어야 한다.</u> 
* 너무 추상적이다? 그럼 추상화가 제대로 됐는지는 어떻게 알 수 있는가? 
* 도메인 전문가만큼 도메인을 깊이 있게 이해하는가? 
* 간혹 특정한 요구사항은 사용자에게서 수집하고 도메인 전문가에게 더 구체적인 용어가 필요할지도 모르지만 도메인 전문가는 해당 분야에 심층적으로 사고할 능력을 갖추었다고 봐야 한다. 



### 문서와 다이어그램

소프트웨어 설계를 논의하는 회의를 할 때마다 **화이트보드**나 **스케치북**에 그림을 그리지 않으면 제대로 되는 경우가 거의 없다.

하지만 문제는 사람들이 UML을 통해 전체 모델이나 설계를 전달해야 한다고 느낄때 생긴다. <u>이런 세부사항이 모두 포함되면 어느 누구도 나무만 보고 숲은 보지 못한다.</u>

설계의 생생한 세부사항은 코드에 담긴다. 보조적인 역할을 수행하는 **다이어그램**과 **문서**를 이용해 **핵심**에 주의를 기울일 수 있다. 

모델은 다이어그램이 아니라는 점을 항상 명심해야 한다. 다이어그램의 목적은 모델을 전달하고 설명하는 데 있다.



#### 글로 쓴 설계 문서

1. 문서는 코드와 말을 보완하는 역할을 해야 한다.
    * 애자일에서는 별도 문서를 유지하지 말고 코드로써 소통하자는 입장
    * 하지만 설계 문서로써 코드에는 한계가 있다.
    * 코드를 읽는 이는 세부사항에 압도될 수 있다. 또한 개발자만 모델을 이해해야 하는 것은 아니다.
2. 문서는 유효한 상태를 유지하고 최신 내용을 담고 있어야 한다.
    * 설계 문서의 가장 큰 가치는 모델의 개념을 설명하고, 코드의 세부사항을 파악해 나가는 데 도움을 준다.
3. 문서는 프로젝트 활동과 관련을 맺고 있어야 한다.
    * 문서가 UBIQUITOUS LANGUAGE와 상호작용하는가?
    * 설계 문서의 용어가 사용되지 않는다면 문서 자체가 잘못된 것이다. 너무 방대하거나 복잡할 수도 있다. 
    * 문서를 읽지 않거나 읽을 필요가 없다고 여긴다.
    * 점차 문서의 중요성은 낮아지고 문서를 최신 상태로 유지하는 것은 노력의 낭비일 뿐이다.



> 문서를 최소한으로 유지하고 코드와 대화를 보완하는데 집중해라.



### 설명을 위한 모델

설계를 주도하는 모델은 도메인을 바라보는 하나의 관점에 해당하지만 도메인의 일반 지식을 전달하기 위해 다른 관점으로 도움을 줄 수 있다. 이러한 목적으로 사람들은 소프트웨어 설계와는 무관한, 모델을 전달하는 그림이나 단어를 활용할 수 있다.

설명을 위한 모델은 훨씬 더 전달력이 높은 의사소통 방식을 만들 수 있다. 도메인 전문가가 사용하는 시각적인 은유는 개발자를 교육하고 전문가 간의 조화로운 합의를 이끌어 내는데 분명한 설명을 제시하곤 한다.

설명을 위한 모델이 객체 모델일 필요는 없으며, 오히려 그렇지 않을 때가 일반적으로 가장 좋다. UML 사용을 자제하고 설계를 주도하는 모델과는 다르다는 것을 인식해야 한다.
# 03 모델과 구현의 연계

**프로젝트 일화**

* 문열고 들어갔을 때 보이는 것은 전체 클래스 다이어그램이었다.
* 사람들이 전체 모델을 심층적으로 조사하고 개발하는데 수개월을 보낸 첫날이었다.
* 모델내의 객체는 서너개의 다른 객체오 복잡한 연관관계를 맺고 있었고 거미줄 같은 관계를 구분하는 경계가 거의 없었다.
* 분석가는 도메인의 특성에만 충실했던 것이었다.
* 얼마 간의 연구 끝에 꽤 많은 것을 배울 수 있었다.
* 하지만 이렇게 학습한 내용이 애플리케이션 코드와 설계에 어떠한 통찰력도 줄 수 없다는 점이었다.
* 애플리케이션 구현이 시작했을 때 개발자는 얽혀있는 연관관계를 트랜잭션 무결성을 준수하면서 저장 및 조회 가능한 단위로 해석할 수 없다는 사실을 금방 깨달았다.
* 객체 데이터베이스를 사용하고 있어서 관계형 테이블 매핑이 필요 없었다.
* 기술 분석가와 업무 전문가의 관점에서는 옳은 것이었지만 구현 과정의 시행착오가 포함되지 않은 개념에 근거한 객체라서 개발자는 활용할 수 없다.
* 개발자는 기조 모델에 근거하지 않고 개발을 진행했다.
* 프로젝트에 도메인 모델은 있었지만 동작하는 소프트웨어를 개발하는 데 직접적으로 도움을 주지 않는 한 종이에 기록된 모델이 무슨 의미가 있겠는가?



## MODEL-DRIVEN DESIGN (모델 주도 설계)

**도메인 모델의 부재**

* 도메인 모델은 전혀 없고 기능만 차례로 구현하기 위해 코드를 작성하는 프로젝트에서는 지식 탐구와 의사소통의 이점을 거의 살리지 못한다. 도메인이 복잡하다면 이러한 프로젝트는 난관에 처할 것이다.

* 도메인 모델을 시도하더라도 모델과 코드를 긴밀하게 연결하지는 못한다. 처음에는 유용할지는 모르지만 모델은 점차 관련성이 떨어진다.



**분석 모델**

* 모델과 코드 간의 연결이 끊어지는 경우는 다양하고 의도적으로 그렇게 할 때도 있다.
* 분석 모델은 설계와 뚜렷이 구분되고 보통 다른 사람이 만든다.
* 분석 모델이라고 하는 이유는 분석 모델이 소프트웨어 시스템에서 수행할 역할에 대해서는 전혀 고려하지 않은 채 업무 도메인의 개념만을 쳬게화하고자 해당 업무 도메인을 분석한 결과물이기 때문이다.
* 분석 모델은 오로지 <u>이해하기 위한 수단</u>으로만 간주된다.
* 순수하게 이론에만 치우친 분석 모델은 코딩이 시작되자마자 폐기되고 대부분의 문제를 다시 검토해야 한다. 



> 설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 안흔ㄴ다면 그 모델은 그다지 가치가 없으며 소프트웨어의 정확함도 의심스러워진다. 동시에 모델의 설계 기능 사이의 복잡한 대응은 이해하기 힘들고, 실제로 설계가 변경되면 유지보수가 불가능해진다. 분석과 설계가 치명적으로 동떨어지고, 그에 따라 각자의 활동에서 얻은 통찰력이 서로에게 전해지지 않는다.



**MODEL-DRIVEN DESIGN**

* MODEL-DRIVEN DESIGN에서는 양쪽 모두의 목적을 달성하는 단일 모델을 찾기 위해 분석모델과 설계를 나누는 이분법은 채택하지 않는다.
* 순수하게 <u>기술적인 쟁점은 배제</u>하고 각 객체는 모델에서 기술한 개념적 열할을 수행하게 된다.



> 소프트웨어 시스템의 일부를 설계할 때는 도메인 모델을 있는 그대로 반영해서 설계와 모델의 대응을 분명하게 하라.
>
> 모델로부터 설계와 기본적인 책임 할당에 사용한 용어를 도출하라. 코드를 작성할 때 그러한 용어를 사용하면 코드가 모델을 표현한 것이 되고, 코드의 변경이 곧 모델의 변경으로 이어질 수 있다.
>
> 구현을 모델과 묶으려면 보통 객체지향 프로그래밍과 같은 모델링 패러다임을 지원하는 언어가 필요하다.



### 모델링 패러다임과 도구 지원

객체지향 프로그래밍은 모델링 패러다임을 근거하고 모델의 구성요소에 대한 구현을 제공하기 때문에 매우 효과적이다.

<예제>



### 내부 드러내기: 왜 모델이 사용자에게 중요한가





## HANDS-ON MODELER (실천적 모델러)

**모델과 코드의 구분**

* 제조업은 소프트웨어 개발 분야에서 인기있는 은유이다.
* 고도의 숙련된 엔지니어는 설계를, 덜 숙련된 노동자는 제품을 조립한다는 것이다.
* '소프트웨어 개발은 모든 것이 설계다'란 한가지 단순한 이유로 많은 프로젝트를 엉망으로 만들었다. 
* <u>분석과 모델링, 설계, 프로그래밍의 책임을 지나치게 구분하는 것은 MODEL DRIVEN DESIGN과 상충한다.</u>
* 관리조직에서는 모델러는 모델링을 해야 하고, 코드를 작성하는 것은 시간 낭비라고 생각하는 경향이 있다.



**문제점**

* 모델의 구현과 기술과의 상호작용에 대한 피드백이 간접적이었다는 것이다.
* 모델의 어떤 측면은 우리가 사용하는 기술 플랫폼에서 매우 비효율적인 것으로 밝혀졌는데, 몇달동안 그 의미를 파악하지 못했다.
* 개발자들은 상아탑에만 머물러 있는 아키텍트의 지시를 받는 위험을 더는 감수할 수 없었다.



> 코드를 작성하는 사람이 모델에 책임을 느끼지 못하거나 애플리케이션을 대상으로 모델이 동작하게 만드는 법을 모른다면 그 모델은 소프트웨어와 무관해진다. 코드의 변경이 곧 모델의 변경이라는 점을 개발자가 인식하지 못하면 리팩터링은 모델을 강화하기보다는 약화시킬 것이다.
>
> 설계자가 구현을 하지 못해 개발자와 업무 단절이 생기면 숙련된 설계자의 지식과 솜씨는 결코 다른 개발자에게 전해지지 못할 것이다.



# 제2부 모델 주도 설계의 기본 요소

소프트웨어 구현을 건전한 상태로 유지하고 모델과의 밀접한 관계를 유지하려면  모델링과 설계의 우수 실천법을 적용해야 한다.

![image-20210220104236265](chapter04.assets/image-20210220104236265.png)





# 04 도메인의 격리



### LAYERED ARCHITECTURE (계층형 아키텍처)

![img](chapter04.assets/dddlayered.png) 



**화물의 목적지를 선택하는 해운 애플리케이션**

1. 위젯을 화면이 그리고
2. 선택 가능한 모든 도시 목록을 데이터베이스에서 조회하며
3. 사용자가 입력한 내용을 해석하고 유효성을 검증하고
4. 선택된 도시를 화물과 연결하며
5. 변경내역을 데이터베이스에 반영한다.

이 중 일부만이 해운 업무와 관련돼 있다.



**프로그램을 작성하는 가장 빠른 방법**

* 객체지향 프로그램에서는 종종 사용자 인터페이스와 데이터베이스, 기타 보조적인 코드를 비즈니스 객체 안에 직접 작성하기도 하다. 
* 부가적인 업무 로직은 UI위젯과 데이터베이스 스크립트에 들어간다. 
* 이런 일이 발생하는 까닭은 단기적으로는 이렇게 하는 것이 뭔가를 동작하게 하는 가장 쉬운 방법이기 때문이다.



**도메인 코드 + 세부적인(기술, DB, UI) 코드**

* 도메인에 관련된 코드가 상당한 양의 도메인과 관련이 없는 다른 코드와 혼재되어 존재하는 경우 도메인에 관련된 코드를 확인하고 추론하기가 굉장히 힘들어진다. 
* UI를 변경하는 것이 실질적으로 업무 로직을 변경하는 것으로 이어질 수 있다. 
* 업무 규칙을 변경하고자 UI코드나 데이터베이스 코드를 추적해야 할지도 모른다. 
* 응집력 있고, 모델 주도적인 객체를 구현하는 것이 비현실적인 이야기가 돼버리고 자동화 테스트가 어려워진다. 



**관심사 분리**

* 매우 복잡한 작업을 처리하는 소프트웨어를 만들 경우 `관심사 분리(separation of concern)`가 필요하며, 이로써 격리된 상태에 있는 각 설계 요소에 집중할 수 있다. 
* 동시에 시스템 내의 정교한 상호작용은 그러한 분리와는 상관없이 유지돼야 한다.



**Layered Architecture (계층형 아키텍처)**

* 한 계층의 모든 요소는 오직 같은 계층에 존재하는 다른 요소나 계층상 "아래"에 위치한 요소에만 의존한다는 것이다.
* 위로 올라가는 의사소통은 반드시 간접적인 메커니즘을 거쳐야 한다.
* 계층화의 가치는 특정 측면만을 전문적으로 다룬다는 데 있다.



**Layered Architecture의 4가지 단계**

* 사용자 인터페이스 (표현 계층)
    * 사용자에게 정보를 보여주고 사용자 명령을 해석하는 일
* 응용 계층
    * 업무 규칙이나 지식이 포함되지 않으며, 오직 작업을 아래 위치한 계층인 도메인 객체의 협력자에게 작업을 위임한다.
* 도메인 계층 (모델 계층)
    * 업무 개념과 업무 상황에 대한 정보
* 인프라스트럭처 계층
    * 기술적 기능을 제공한다.
    * 메시지 전송, 도메인 영속화, UI에 위젯을 그리는 것



> 중요한 것은 도메인 계층을 다른 계층과 분리하는 것에 있다.
>
> * 복잡한 프로그램을 여러 개의 계층으로 나눠라.
> * 응집력 있고 오직 아래에 위치한 계층에만 의존하도록 해라.
> * 상위 계층과의 결합을 느슨하게 유지하라.
> * 도메인 모델과 관련된 코드는 모두 한 계층에 모으고 사용자 인터페이스 코드나 애플리케이션 코드, 인프라스트럭처 코드와 격리하라.
> * 도메인 객체는 도메인 모델을 표현하는 것에만 집중할 수 있다.
> * 모델은 진화를 거듭해 본질적인 업무 지식을 포착해서 해당 업무 지식이 효과를 발휘할 수 있을 만큼 풍부하고 명확해질 것이다.



예제: 온라인 뱅킹



### 계층 간 관계 설정

* 각 계층은 오직 한 방향으로만 둬서 느슨하게 결합된다.
* 상위 계층은 하위 계층의 공개 인터페이스를 호출한다.
* 하위 수준의 객체가 상위객체와 소통해야 할 경우 콜백이나 관찰자 패턴같은 아키텍처 패턴을 활용할 수 있다.



### 아키텍처 프레임워크



### 도메인 계층은 모델이 살아가는 곳



## SMART UI(지능형 UI) "안티 패턴"

SMART UI는 도메인 주도 설계 접근법과는 서로 양립할 수 없는 상호 배타적인 길에 놓인 접근법이다.



**SMART UI의 장점**

* 애플리케이션이 단순한 경우 생산성이 높고 효과가 즉각적으로 나타난다.
* 다소 능력이 부족한 개발자도 약간의 교육으로 업무를 진행할 수 있다.
* 요구사항 분석 단계에서 결함이 발생하더라도 요구에 맞게 제품을 변경해서 문제를 해결할 수 있다.
* 애플리케이션이 분리되므로 납기 일정을 계획할 수 있고 간단한 작업으로 시스템 확장하가기 수월하다.
* 관계형 데이터베이스와 잘 어울리고 데이터 수준의 통합이 가능하다.
* 4세대 언어 도구와 잘 어울린다.
* 유지보수 시 신속하게 작업을 진행할 수 있다. UI에 국한되기 때문이다.



**SMART UI의 단점**

* 데이터베이스를 이요하는 방식 말고는 여러 애플리케이션을 통합하기가 수월하지 않다.
* 행위를 재사용하지 않으며 업무 문제에 대한 추상화가 이뤄지지 않는다. 업무 규칙이 적용되는 연산마다 업무 규칙이 중복된다.
* 복잡성이 금방 압도되어 애플리케이션의 성장 경로가 단순 응용으로만 향한다.



# 05 소프트웨어에서 표현되는 모델

## 연관관계

# 제3부 더 심층적인 통찰력을 향한 리팩토링

## 리팩터링 수준



**리팩터링**

* 소프트웨어의 기능을 수정하지 않고 설계를 다시 하는 것을 의미한다
* 기존의 기능은 유지한 채 끊임없이 코드를 변경하면서 설계를 좀 더 유연하게 개선하거나 이해하기 쉽게 만든다.
* 자동화된 단위 테스트 스위트가 구비돼 있다면 비교적 안전하게 리팩터링을 수행할 수 있다.
* 그러나 대부분의 리팩터링은 코드의 가독성을 높이거나 쉽게 개선하는 기계적인 변경이 초점을 맞춘다.

<== 마이크로 리팩터링



시스템의 생존력에 가장 큰 영향을 미치는 리팩터링은 도메인에 대한 새로운 통찰력을 얻었을 때 수행하거나 코드를 사용해서 모델이 표현하고자 하는 바를 명확하게 드러내고자 수행하는 경우다. 이런 유형의 리팩터링은 디자인 패턴을 향한 리팩터링이나 마이크로 리팩터링을 대체하는 것은 아니다. 



## 심층 모델

심층 모델이란 도메인의 피상적인 측면은 배제하고 도메인 전문가의 주요 관심사와 가장 적절한 지식을 알기 쉽게 표현하는 모델이다. 이 정의가 추상화를 의미하는 것은 아니다.



## 심층 모델/유연한 설계



## 발견 과정



# 08 도약

* 리팩터링의 효과는 선형적으로 증가하지 않는다.
* 리팩터링은 레거시 시스템이 퇴보하는 것을 막는 최전선에 놓여있다.
* 가장 중요한 통찰력은 어느 순간 갑자기 떠오르고 그에 따른 충격은 프로젝트 전체로 퍼져나간다.
* 복잡성이 사라지는 바로 그때 갑자기 모델의 융통성과 표현력이 높아진다.



## 도약에 관한 일화









## 서문

이 책은 설계와 관련된 의사결정을 내리는 데 <u>기반이 되는 틀</u>과 도메인 설계에 대한 논의할 때 사용되는 <u>기술적인 어휘</u>를 제공한다.



## 세 프로젝트 비교

1. case 
    * 단순한 웹 기반 거리 시스템
    * 개발자들은 임기응변 식으로 처리
    * 설계에 신경 쓰지 않고도 만들 수 있어서 문제가 없었음
    * 프로젝트가 성공하자 향후 기대치가 매우 높아짐
    * 내가 차기 버전의 작업을 의뢰받음
    * 프로젝트 공통 언어조차 없었고 구조화 되지 않은 설계만이 있음
    * 프로젝트 리더는 내가 이렇게 평가한 데 동의하지 않았고 작업 의뢰를 거절했다.
    * 1년이 지난 후 난항 끝에 차기 버전은 인도하지 못함.
    * 프로젝트 실패 이유는 기술을 미숙하게 사용하기도 했지만 주된 원인은 업무 로직을 성공적으로 다루지 못한데 있음.
        첫번째 시스템이 너무 일찍 유지보수 비용이 많이 드는 레거시 시스템으로 굳어버린 것이다.

2. case
    * 복잡성으로 생기는 한계를 극복하려면 도메인 로직 설계에 좀 더 진지하게 접근해야 한다.
    * 경력 초기에 운좋게도 도메인 설계를 강조한 프로젝트에 참여한 적 있다.
    * 이 프로젝트에서는 복잡성이 첫 번째 프로젝트 수준인 도메인을 다뤘고, 기관 매매자가 사용할 간단한 애플리케이션을 인도하면서 적당한 성공을 거둠
    * 위의 사례와는 다르게 초기 인도는 점점 개발에 박차를 가하며 진행됐다. 
    * 팀원들은 매매자의 요구사항에 유연함과 확장 능력을 토대로 대응할 수 있었다.
    * 코드 안에 정제되고 표현되는 예리한 도메인 모델이 있었기에 가능했다.
    * 팀원들은 도메인에 대한 새로운 통찰력을 얻으면서 모델은 깊이를 더해갔다.
    * 의사소통의 품질은 개발자와 개발자 사이는 물론 개발자와 도메인 전문가 사이에서도 향샹되었고, 설계는 큰 유지보수 부담을 주는 것이 아닌 변경이나 확장이 점점 쉬워지는 구조로 바뀌었다.
3. case
    * 단순히 모델을 중요하게 취급한다고 해서 점차 향상되는 선순환에 이르지는 않는다.
    * 내가 참여했던 한 프로젝트는 도메인 모델을 기반으로 세계적인 기업 시스템을 구축하겠다는 원대한 목표를 가지고 시작됐지만 몇 년간의 실망스러운 성과를 낸 후 평범한 수준에 머물렀다.
    * 팀원은 좋은 도구를 갖고 있었고 업무를 잘 이해하고 있었으며 모델링에 세심한 주의를 기울였다. 
    * 그러나 개발자 역할을 분담하는 데 오류를 범함으로써 <u>모델링과 구현이 단절</u>됐고, 심층적인 <u>분석 내용이 설계에 반영되지 못하는 결과</u>가 초래됐다.
    * 세부적인 업무 객체의 설계는 정교한 애플리케이션에 해당 객체들을 결합시킬 만큼 엄밀하지 못했다.
    * 개발자들은 모델 기반 객체를 만들어 내기 위한 비공식적인 형식과 기법을 알지 못했다.
    * 몇 달후 개발 업무를 복잡성이라는 수렁에 빠졌고 팀원들은 시스템에 대한 응집력 있는 비전을 잃어버렸다.



## 복잡성이라는 도전 과제

관료주의, 불명확한 목표, 자원 부족 등 다양한 이유로 프로젝트가 궤도에서 이탈한다. 얼마나 복잡한 소프트웨어를 만들어 낼 수 있는가를 결정하는 주된 요인은 설계 접근법에 있다.

복잡성을 감당할 수 없다면 개발자는 더는 쉽고 안전하게 변경하거나 확장할 수 있을 만큼 소프트웨어를 파악하지 못한다.

어떤 설계요소는 기술과 관련이 있다.

그러나 수많은 애플리케이션에서 가장 중요한 복잡성은 기술적인 것이 아니다. 그것은 바로 사용자의 활동이나 업무에 해당하는 도메인 자체다.

<u>이 책의 전제는 다음과 같다.</u>

1. 대부분의 소프트웨어 프로젝트에서는 가장 먼저 도메인과 도메인 로직에 집중해야 한다.
2. 복잡한 도메인 설계는 모델을 기반으로 해야 한다.

도메인 주도 설계는 복잡한 도메인을 다뤄야 하는 소프트웨어 프로젝트에 박차를 가하는 것을 목표로 삼는 사고방식이자 우선순위의 모음이다. 이러한 목표를 달성하고자 이 책에서는 설계 실천법, 기법, 원칙을 폭넓게 제시한다.



## 설계 vs. 개발 프로세스

설계 개념은 성공적으로 구현해야 하며, 그렇지 않으면 학문적 토론에 그치고 만다.

설계 기법을 배울 때면 사람들은 설계 기법의 실현 가능성에 들뜨곤 한다. 그런 다음에는 실제 프로젝트의 어지러운 현실이 그들에게 닥친다.
그들은 사용해야 할 기술에 새로운 설계 아이디어를 맞추지 못한다. 혹은 시간 관계상 특정 설계 관점을 포기해야 한다. 개발자들은 설계 원칙의 적용을 두고 서로 추상적으로 얘기를 나눌 수도 있지만 실제로 어떻게 되는지를 이야기하는 게 더 자연스럽다.

이 책의 접근법을 적용하기 위한 선행 조건이다.

1. **개발은 반복주기를 토대로 진행돼야 한다**. 애자일 개발 방법론의 토대다.
2. **개발자와 도메인 전문가는 밀접한 관계에 있어야 한다**. 도메인 주도설계는 모델을 만들어 내는데 이는 도메인에 대한 깊은 통찰력과 핵심개념에 집중한 바를 반영한다. 이것은 도메인 전문가와 소프트웨어 개발자 사이에서 일어나는 협업의 결과도. 



## 이 책의 구성

**1부, "동작하는 도메인 모델 만들기"**에서는 도메인 주도 설계의 기본적인 목표를 제시한다. 소프트웨어 개발을 위한 접근법을 설명

**2부, "모델 주도 설계의 기본 요소"**에서는 객체지향 도메인 모델링에서의 우수 실천법의 핵심을 몇가지 기본 요소로 요약한다. 모델과 실제로 동작하는 소프트웨어 간의 간극을 메우는 데 초첨을 맞춘다. <== 표준화된 패턴을 활용하면 질서정연한 설계가 가능해진다. 팀원들이 서로의 업무를 더 쉽게 이해할 뿐더라 표준화된 패턴을 사용하면 공통 언어에 함께 쓸 수 있는 용어가 마련되어 모델과 설계에 대한 의사결정을 내리는 자리에서 이러한 용어를 사용할 수 있다.

**3부, "더 심층적인 통찰력을 향한 리팩터링"**에서는 실용적인 모델을 만드는 것과 관련된 도전과제를 다룬다. 난해한 설계 원칙을 바로 적용하는 것이 아니라 발견 과정을 강조한다.

**4부, "전략적 설계"**에서는 복잡한 시스템, 더 큰 조직, 외부 시스템 및 기존 시스템과의 상호작용에서 발생하는 상황을 다룬다.

