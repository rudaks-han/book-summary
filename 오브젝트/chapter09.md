# 9장 유연한 설계

* 이번 장에서는 기 기법들을 원칙이라는 관점에서 정리하겠다.
* 설계를 논의할 때 사용할 수 있는 공통의 어휘를 익힌다는 점에서도 가치가 있을 것이다.



## 01 개방-폐쇄 원칙

로버트 마틴은 확장 가능하고 변화에 유연하게 대응할 수 있는 설계를 만들 수 있는 원칙 중 하나로 **개방-폐쇄 원칙(Open-Closed Principle, OCP)**를 고안했다.

> 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해 닫혀 있어야 한다.

여기서 키워드는 '확장'과 '수정'이다. 이 둘은 순서대로 애플리케이션의 '동작'과 '코드'의 관점을 반영한다.

* 확장에 대해 열려 있다: 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.
* 수정에 대해 닫혀 있다: 기존 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.



### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

* 개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다.
* 런타임 의존성은 실행시에 협력에 참여하는 객체들 사이의 관계다.
* 컴파일타임 의존성은 코드에서 드러나는 클래스들 사이의 관계다.
* 영화 예매 시스템의 할인 정책
    * 컴파일타임 의존성 관점
        * Movie 클래스는 추상 클래스인 DiscountPolicy에 의존한다.
    * 런타임 의존성 관점
        * Movie 인스턴스는 AmountDiscountPolicy와 PercentDiscountPolicy에 의존한다.



### 추상화가 핵심이다

* 개방-폐쇄 원칙의 핵심은 **추상화에 의존하는 것**이다.
* 추상화란 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다.
* DiscountPolicy
    * 변하지 않는 부분은 할인 여부를 판단하는 로직이고
    * 변하는 부분은 할인된 요금을 계산하는 방법이다.
* 변하는 부분을 고정하고 변하지 않는 부분을 생략하는 추상화 매커니즘이 개방-폐쇄 원칙의 기반이 된다는 사실에 주목하라.



## 02 생성 사용 분리

* 유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임을 서로 다른 객체로 분리해야 한다.
* 하나는 객체를 생성하는 것이고, 다른 하나는 객체를 사용하는 것이다.
* 한 마디로 말해서 객체에 대한 생성과 사용을 분리해야 한다.
* 사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것이다.
* 다시 말해 Movie의 클라이언트가 적절한 DiscountPolicy 인스턴스를 생성한 후 Movie에게 전달하게 하는 것이다.



### FACTORY 추가하기





### 순수한 가공물에게 책임 할당하기

* FACTORY는 도메인 모델에 속하지 않는다.
* FACTORY를 추가한 이유는 순수하게 기술적인 결정이다.
* 전체적으로 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에게 할당돼 있던 객체 생성 책임을 도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동시킨 것이다.
* 크레이그 라만은 시스템을 객체로 분해하는 데는 크게 두 가지 방식이 존재한다고 설명한다.
* 하나는 **표현적 분해(representational decomposition)**이고 다른 하나는 **행위적 분배(behavioral decomposition)**다.
* 표현적 분해
    * 도메인에 존재하는 사술 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것이다.
    * 도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 몾거으로 한다.
    * 객체지향 설계를 위한 가장 기본적인 접근법이다.
* 모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제점에 봉착하게 될 가능성이 높아진다.
* 이 경우 도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 만들어낸 가곡의 객체에게 책임을 할당해서 문제를 해결해야 한다.
* 크레이크 라만은 이처럼 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체를 **PURE FABRICATION(순수한 가공물)**이라고 부른다.
* 어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면 PURE FABRICATION을 추가하고 이 객체에게 책임을 할당하라.
* 따라서 PURE FABRICATION은 표현적 분해보다는 행위적 분해에 의해 생성되는 것이 일반적이다.



## 03 의존성 주입

* 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 **의존성 주입(Dependency Injection)**이라고 부른다.



### 숨겨진 의존성은 나쁘다

* SERVICE LOCATOR는 의존성을 해결할 객체들을 보관하는 일종의 저장소다.
* SERVICE LOCATOR의 경우 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해줄 것을 요청한다.
* SERVICE LOCATOR 패턴의 가장 큰 단점은 의존성을 감춘다는 것이다.
* Movie는 DiscountPolicy에 의존하고 있지만 Movie의 퍼블릭 인터페이스 어디에도 이 의존성에 대한 정보가 표시돼 있지 않다.



## 04 의존성 역전 원칙

### 추상화와 의존성 역전

* 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다.
* 의존성 역전 원칙(Dependency Inversion Principle, DIP)
    1. 상위 주순의 모듈은 하위 수훈의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
    2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.



### 의존성 역전 원칙과 패키지





## 05 유연성에 대한 조언

### 유연한 설계는 유연성이 필요할 때만 옳다

* 유연하고 재사용 가능한 설계가 항상 좋은 것은 아니다.
    * 설계의 이덕은 단순함과 명확함으로부터 나온다.
    * 단순하고 명확한 설계를 가진 코드는 일기 쉽고 이해하기도 편하다.
* 유연한 설계라는 말의 이면에는 복잡한 설계라는 의미가 숨어 있다.
    * 유연한 설계의 이런 양면성은 객관적으로 설계를 판단하기 어렵게 만든다.
    * 이 설계가 복잡한 이유는 무엇인가?
    * 어떤 변경에 대비하기 위해 설계를 복잡하게 만들었는가?
    * 정말 유연성이 필요한가?
    * 정보가 제한적인 상황에서 이런 질문에 대답하는 것은 공학이라기보다는 심리학에 가깝다.
    * 변경은 예상이 아니라 현실이어야 한다.
    * 미래에 변경이 일어날지도 모른다는 막연한 불안감은 불필요하게 복잡한 설계를 낳는다. 
    * 아직 일어나지 않은 변경은 변경이 아니다.
* 설계가 유연할수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다.
* 불필요한 유연성은 불필요한 복잡성을 낳는다.



### 협력과 책임이 중요하다





