# 2장 객체지향 프로그래밍

## 01 영화 예매 시스템

### 요구사항 살펴보기

* '할인 조건은'은 가격의 할인 여부를 결정하며 '순서 조건'과 '기간 조건'의 두 종류로 나눌 수 있다.
* '순서 조건'은 상영 순번을 이용해 할인 여부를 결정하는 규칙이다.
* '기간 조건'은 영화 상영 시간을 이용해 할인 여부를 결정한다.
* '할인 정책'은 할인 요금을 결정한다.
* 할인 정책에는 '금액 할인 정책'과 '비율 할인 정책'이 있다.
* '금액 할인 정책'은 예매 요금에서 일정 금액을 할인해주는 방식이며 '비율 할인 정책'은 정가에서 일정 비율의 요금을 할인해 주는 방식이다.
* 영화별로 하나의 할인 정책만 할당할 수 있다.



## 02 객체지향 프로그래밍을 향해

### 협력, 객체, 클래스

객체지향 프로그램을 작성할 때 가장 먼저 고려하는 것은 무엇인가?
==> 객체지향 언어에 익숙한 사람이라면 가장 먼저 어떤 클래스가 필요한지 고민할 것이다.

안타깝게도 이것은 객체지향의 본질과는 거리가 멀다. 객체지향은 말 그래도 객체를 지향하는 것이다.

진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다. 이를 위해서는 다음의 두 가지에 집중해야 한다.

* 첫째, 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하라.
    * 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다.
    * 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.

* 둘째, 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.
    * 훌륭한 협력이 훌륭한 객체를 낳고 훌륭한 객체가 훌륭한 클래스를 낳는다.



### 도메인의 구조에 따르는 프로그램 구조

* 영화라는 개념은 Movie 클래스
* 상영이라는 개념은 Screening 클래스
* 할인 정책은 DiscountPolicy
* 금액 할인 정책은 AmountDiscountPolicy
* 비율 할인 정책은 PercentDiscountPolicy
* 기간 조건은 PeriodCondition
* 예매라는 개념은 Reservation



### 클래스 구현하기

클래스의 내부와 외부를 구분해야 하는 이유는 무엇일까? 그 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문이다.



#### 자율적인 객체

먼저 두 가지 중요한 사실을 알아야 한다.

* 첫 번째 사실은 객체가 **상태(state)**와 **행동(behavior)**을 함께 가지는 복합적인 존재라는 것이다.
* 두 번째 사실은 객체가 스스로 판단하고 행동하는 **자율적인 존재**라는 것이다.

데이터와 기능을 객체 내부로 함께 묶는 것을 **캡슐화**라고 부른다.

캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.

* 하나는 외부에서 접근이 가능한 부분으로 이를 퍼블릭 <u>인터페이스</u>라고 부른다.
* 다른 하나는 외부에서 접근이 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 <u>구현</u>이라고 부른다.



#### 프로그래머의 자유



### 협력하는 객체들의 공동체



### 협력에 관한 짧은 이야기

* 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 **메시지를 전송(send a message)**하는 것뿐이다. 
* 다른 객체에게 요청이 도착할 때 해당 객체가 **메시지를 수신(receive a message)**했다고 이야기한다.
* 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드(method)**라고 부른다.



## 03 할인 요금 구하기

### 할인 요금 계산을 위한 협력 시작하기



### 할인 정책과 할인 조건

* DiscountPolicy는 할인 여부와 요금 계산에 필요한 전체적인 흐름은 정의하지만 실제로 요금을 계산하는 부분은 추상 메서드인 getDiscountAmount 메서드에게 위임한다.
* 실제로는 DiscountPolicy를 상속받은 자식 클래스에서 오버라이딩한 메서드가 실행될 것이다.
* 이처럼 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 **TEMPLATE METHOD** 패턴이라고 부른다.



### 할인 정책 구성하기

* 할인 정책은 하나만 설정할 수 있지만 할인 조건의 경우에는 여러 개를 적용할 수 있다.



## 04 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성

* Movie는 DiscountPolicy 클래스와 연결돼 있다.
* 영화 요금을 계산하기 위해서는 추상 클래스인 DiscountPolicy가 아니라 AmountDiscountPolicy와 PercentDiscountPolicy 인스턴스가 필요하다.

여기서 이야기하고 싶은 것은 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다는 것이다.

* 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다는 것이다.
* 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 더 유연해지고 확장 가능해진다.

무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다.

* 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다.
* 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다.



### 차이에 의한 프로그래밍

상속은 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있는 간편한 방법을 제공한다.

이처럼 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 **차이에 의한 프로그래밍(programming by difference)**이라고 부른다.



### 상속과 인터페이스

인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다. 상속을 통해 자식 클래스는 자신의인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.

자식 클래스가 부모 클래스를 대신하는 것을 **업캐스팅(upcasting)**이라고 부른다.



### 다형성

Movie는 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 클래스의 클래스가 무엇이냐에 따라 달라진다. 이를 **다형성**이라고 부른다.

* 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
* 프로그램을 작성할 때 Movie 클래스는 추상 클래스인 DiscountPolicy에 의존한다.
* 반면 실행 시점에 Movie의 인스턴스와 실제로 상호작용하는 객체는 AmountDiscountPolicy나 PercentDiscountPolicy의 인스턴스다.
* 이처럼 다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행할 수 있게 한다.

다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를 <u>컴파일 시점이 아닌 실행 시점에 결정</u>한다는 공통점이 있다. 이를 **지연 바인딩(lazy binding)** 또는 **동적 바인딩(dynamic  binding)**이라고 부른다.

전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 **초기 바인딩(early binding)** 또는 **정적 바인딩(static binding)**이라고 부른다.



###  인터페이스와 다형성

구현은 공유할 필요가 없고 순수하게 인터페이스만 공유하고 싶을 때가 있다. 자바에서는 인터페이스라는 프로그래밍 요소를 제공한다.



## 05 추상화와 유연성

### 추상화의 힘

추상화를 사용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다. 추상화의 이런 특징은 세부사항에 억눌리지 않고 상위 개념만으로도 <u>도메인의 중요한 개념을 설명</u>할 수 있게 한다.

두 번째 특징은 첫 번째 특징으로부터 유추할 수 있다. 추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다. 다시 말해 <u>유연하게 만들 수 있다</u>.



### 유연한 설계



### 추상 클래스와 인터페이스 트레이드 오프



### 코드 재사용

* 상속은 코드를 재사용하기 위해 널리 사용되는 방법이다.
* 객체지향 설계와 관련된 자료를 조금이라도 본 사람들은 코드 재사용을 위해서는 상속보다는 **합성(composition)**이 더 좋은 방법이라는 이야기를 많이 들었을 것이다. 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.



### 상속

* 상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이다. 하지만 두 가지 관점에서 설계에 안 좋은 영향을 미친다.
* 하나는 상속이 캡슐화를 위반하는 것이고, 다른 하나는 설계를 유연하지 못하게 만든다는 것이다.
* 상속의 가장 큰 문제는 캡슐화를 위반하는 것이다.
    * 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.
    * 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.
    * 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워진다.
* 상속의 두 번째 단점은 설계가 유연하지 않다는 점이다.
    * 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.



### 합성

* 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 **합성**이라고 부른다.
* 합성은 상속이 가지는 두 가지 문제점을 모두 해결한다.
* 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.
* 또한 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.
* 상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 메시지를 통해 느슨하게 결합된다.

























