# 8장 의존성 관리하기

* 잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성된다.
    * 작고 응집도 높은 객체란 책임의 초점이 명확하고 한 가지 일만 잘 하는 객체를 의미한다.
    * 이런 작은 객체들이 단독으로 수행할 수 있는 작업은 거의 없기 때문에 다른 객체에게 도움을 요청해야 한다.
    * 이런 요청이 객체 사이의 협력을 낳는다.
* 협력은 필수적이지만 과도한 협력은 설계를 곤경에 빠트릴 수 있다.
    * 협력은 객체가 다른 객체에 대해 알것을 강요한다.
    * 이런 지식이 객체 사이의 의존성을 낳는다.
* 협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다.
    * 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술이라고 할 수 있다.



## 01 의존성 이해하기

### 변경과 의존성

* 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.
    * **실행 시점**: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
    * **구현 시점**: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
* Screening이 변경될 때 PeriodCondition이 영향을 받게 되지만 그 역은 성립하지 않는다.



### 의존성 전이

* 의존성 전이가 의미하는 것은 PeriodCondition이 Screening에 의존할 경우 PeriodCondition은 Screening이 의존하는 대상에 대해서도 자동적으로 의존하게 된다는 것이다.



### 런타임 의존성과 컴파일타임 의존성

* 객체지향 애플리케이션에서 런타임의 주인공은 객체다.
* 따라서 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다.
* 반면 코드 관점에서 주인공은 클래스다. 따라서 컴파일 타임 의존성이 다루는 주제는 클래스 사이의 의존성이다.



### 컨텍스트 독립성

* 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 **컨텍스트 독립성**이라고 부른다.
* 설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스에 대한 구체적인 정보를 최대한 적게 알아야 한다.
* 컨텍스트에[ 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용될 수 있기 때문이다.



### 의존성 해결하기

* 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다.
* 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 부른다. 
* 의존성을 해결하기 위해서는 일반적으로 다음과 같은 세 가지 방법을 사용한다.
    * 객체를 생성하는 시점에 생성자를 통해 의존성 해결
    * 객체 생성 후 setter 메서드를 통해 의존성 해결
    * 메서드 실행 시 인자를 이용해 의존성 해결

```java
// 생성자 이용
Movie avata = new Movie("아바타",
                       Duration.ofMinutes(120),
                       Money.wons(10000),
                       new AmountDiscountPolicy(...));

// 메서드 이용
Movie avata = new Movie(...);
avatar.setDiscountPolicy(new AmountDiscountPolicy(...));

// 생성자 + 메서드 이용
Movie avata = new Movie(..., new PercentDiscountPolicy(...));
...
avatar.setDiscountPolicy(new AmountDiscountPolicy(...));
```



## 유연한 설계

### 의존성과 결합도

* Movie가 비율 할인 정책을 구현하는 PecentDiscountPolicy에 직접 의존한다고 가정해보자.
* Movie가 AmountDiscountCondition과도 협력해야 한다면 어떻게 해야 할까?
* 해결 방법은 의존성을 바람직하게 만드는 것이다.
* Movie가 협력하고 싶은 대상의 반드시 PercentDiscountCondition의 인스턴스일 필요는 없다는 사실
    * 자신이 전송한느 calculateDiscountAmount 메시지를 이해할 수 있고 할인된 요금을 계산할 수 있다면 상관없다.
* 이 예는 의존성 자체가 나쁜 것이 아니라는 사실을 보여준다.
    * 의존성은 협력을 위해 반드시 필요한 것이다. 단지 바람직하지 못한 의존성이 문제일 뿐이다.
* 그렇다면 바람직한 의존성이란 무엇인가?
    * 바람직한 의존성은 재사용성과 관련이 있다.
    * 특정 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.
* 바람직한 의존성과 바람직하지 못한 의존성을 가리키는 좀 더 세련된 용어가 존재한다.
    * 결합도가 바로 그것이다.
    * 느슨한 결합도 또는 약한 결합도, 단단한 결합도 또는 강한 결합도



### 지식이 결합을 낳는다

* 서로에 대해 알고 있는 지식의 양이 결합도를 결정한다.
* 더 많이 알수록 더 많이 결합된다.
* 결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다.
* 이 목적을 달성할 수 있는 가장 효과적인 방법에 대해 이미 알고 있다는 것이다.
    * 추상화가 바로 그것이다.



### 추상화에 의존하라

* 추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해서 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.



### 명시적인 의존성





### new는 해롭다

* 결합도 측면에서 new가 해로운 이유는 크게 두 가지다.
    * new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. 따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높아진다.
    * new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 할는지도 알아야 한다. 따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.
* 해결 방법은 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 부닐하는 것이다.
    * AmountDiscountPolicy를 사용하는 Movie는 인스턴스를 생성해서는 안 된다. 단지 해당하는 인스턴스를 사용하기만 해야 한다.
    * 이를 위해 Movie는 외부로부터 이미 생성된 AmountDiscountPolicy의 인스턴스를 전달받아야 한다.



### 가끔은 생성해도 무방하다





### 표준 클래스에 대한 의존은 해롭지 않다





### 컨텍스트 확장하기

* 첫 번째는 할인 혜택을 제공하지 않는 영화의 예매 요금을 계산하는 경우다.
    * 쉽게 생각할 수 있는 방법은 discountPolicy에 null을 할당
    * calculateMovieFee에 null인지 체크한다.
    * 해결책은 할인 정책이 존재하지 않는다는 사실을 예외 케이스로 처리하지 말고 기존 Movie와 DiscountPolicy가 협력하던 방식을 따르도록 만드는 것이다.
* 두 번째 예는 중복 적용이 가능한 할인 정책을 구현하는 것이다.
    * public class OverlappedDiscountPolicy extends DiscountPolicy
    * Movie를 수정하지 않고도 할인 정책을 적용하지 않는 새로운 기능을 추가하는 것이 얼마나 간단한지를 잘 보여준다.



### 조합 가능한 행동

