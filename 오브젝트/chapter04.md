# 4장 설계 품질과 트레이드 오프

객체지향 설계의 핵심은 역할, 책임, 협력이다.

* 협력은 애플리케이션의 기능을 구현하기 위해 <u>메시지를 주고 받는 객체들 사이의 상호작용이다</u>
* 책임은 객체가 다른 객체와 협력하기 위해 <u>수행하는 행동</u>
* 역할을 <u>대체 가능한 책임의 집합이다</u>

객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.

이 정의에는 객체지향 설계에 관란 두 가지 관점이 섞여 있다.

* 첫 번째 관점은 객체지향 설계의 핵심이 책임이라는 것이다.
* 두 번째 관점은 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관돼 있다는 것이다.



## 01 데이터 중심의 영화 예매 시스템

객체지향 설계에서는 두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다.

* 첫 번째 방법은 상태를 분할의 중심축으로 삼는 방법
* 두 번째 방법은 책임을 분할의 중심축으로 삼는 방법

시스템을 분할하기 위해 데이터와 책임 중 어느 것을 선택해야 할까? 결론부터 말하자면 훌륭한 객체지향 설계는 <u>데이터가 아니라 책임에 초점을 맞춰야 한다</u>. 이유는 변경과 관련이 있다.

* 상태
    * 객체의 상태는 구현에 속한다.
    * 구현은 불안정하기 때문에 변하기 쉽다.
    * 상태를 객체 분할의 중심축으로 삼으로 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너진다.
    * 결과적으로 상태 변경은 인터페이스의 변경을 초래하며 이 인터페이스에 의존하는 모든 객체에게 변경의 영향이 퍼지게 된다.
    * 따라서 데이터에 초점을 맞추는 설계는 변경에 취약할 수밖에 없다.
* 책임
    * 객체의 책임은 인터페이스에 속한다.
    * 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼저나가는 것을 방지한다.
    * 따라서 책임에 초점을 맞추면 상대적으로 변경에 안정적인 설계를 얻을 수 있게 된다.



### 데이터를 준비하자

* 기본적인 정보인 영화 제목, 상영시간, 기본 요금은 동일하다.
* 차이점은 할인 조건의 목록이 인스턴스 변수로 Movie안에 직접 포함돼 있다는 것이다.
* 또한 할인 정책을 DiscountPolicy라는 별도의 클래스로 분리했던 이전 예제와 달리 Movie안에 직접 정의하고 있다.
* 할인 정책의 종류를 결정하기 위해서 movieType을 사용한다.



### 영화를 예매하자



## 02 설계 트레이드 오프

### 캡슐화

상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서다. 여기서 구현이란 나중에 변경될 가능성이 높은 어떤 것을 가리킨다.

변경될 가능성이 높은 부분을 **구현**이라고 부르고 상대적으로 안정적인 부분을 **인터페이스**라고 부른다.

설계가 필요한 이유는 요구사항이 변경되기 때문이고, <u>캡슐화가 중요한 이유</u>는 <u>불안정한 부분과 안정적인 부분을 분리</u>해서 <u>변경의 영향을 통제</u>할 수 있기 때문이다. 따라서 변경의 관점에서 설계의 품질을 판단하기 위해 캡슐화를 기준으로 삼을 수 있다.

정리하면 캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.

객체 내부에 무엇을 캡슐화해야 하는가? 변경될 수 있는 어떤 것이라도 캡슐화해야 한다. 이것이 바로 객체지향 설계의 핵심이다.



### 응집도와 결합도

* 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다.
* 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.

좋은 설계란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다.

높은 응집도와 낮은 결합도를 가진 설계를 추구해야 하는 이유는 단 한 가지다. 그것이 설계를 변경하기 쉽게 만들기 때문이다.

* 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이고 모듈의 일부분만 변경된다면 응집도가 낮은 것이다.



## 03 데이터 중심의 영화 예매 시스템의 문제점

데이터 중심의 설계가 가진 대표적인 문제점을 다음과 같이 요약할 수 있다.

* 캡슐화 위반
* 높은 결합도
* 낮은 응집도



### 캡슐화 위반

* Movie가 캡슐화의 원칙을 어기게 된 근본적인 원인은 객체가 수행할 책이밍 아니라 내부에 저장할 데이터에 초점을 맞췄기 때문이다.
* 앨런 홀럽은 접근자와 수정자에 과도하게 의존하는 설계 방식을 **추측에 의한 설계 전략(design-by-guessing strategy)**이라고 부른다.



### 높은 결합도

* ReservationAgent는 한 명의 예매 요금을 계산하기 위해 Movie의 getFee 메서들 호출하며 계산된 결과를 Money 타입의 fee에 저장한다. 이때 fee의 타입을 변경한다고 가정해보자.
    * getFee 메서드의 반환 타입도 함께 수정해야 할 것이다.
    * ReservationAgency의 구현도 수정해야 할 것이다.
* ReservationAgency가 모든 데이터 객체에 의존한다는 것을 알 수 있다. 시스템 안의 어떤 변경도 ReservationAgency의 변경을 유발한다.



### 낮은 응집도

다음과 같은 수정사항이 발생하는 경우에 ReversationAgency의 코드를 수정해야 할 것이다.

* 할인 정책이 추가될 경우
* 할인 정책별로 할인 요금 계산하는 방법이 변경될 경우
* 할인 조건이 추가되는 경우
* 할인 조건별로 할인 여부를 판단하는 방법이 변경될 경우
* 예매 요금을 계산하는 방법이 변경될 경우

낮은 응집도는 두 가지 측면에서 설계에 문제를 일으킨다.

* 변경과 아무 상관이 없는 코드들이 영향을 받게 된다.
    * 예를 들어 ReservationAgency 안에 할인 정책을 선택하는 코드와 할인 조건을 판단하는 코드가 함께 존재하기 때문에 새로운 할인 정책을 추가하는 작업이 할인 조건에도 영향을 미칠 수 있다.
* 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다.
    * 새로운 할인 정책을 추가해야 한다고 가정해보자.
    * MovieType에 새로운 할인 정책을 표현하는 열거형 값을 추가
    * ReservationAgency의 reserve 메서드의 switch 구문에 추가해야하고
    * 필요한 데이터를 Movie에 추가



## 04 자율적인 객체를 향해

### 캡슐화를 지켜라



### 스스로 자신의 데이터를 책임지는 객체



## 05 하지만 여전히 부족하다

### 캡슐화 위반



### 높은 결합도



### 낮은 응집도



## 06 데이터 중심 설계의 문제점

### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다



### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다



