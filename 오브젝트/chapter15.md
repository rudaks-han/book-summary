# 15장 디자인 패턴과 프레임워크

* 애플리케이션을 설계하다 보면 어떤 요구사항을 해결하기 위해 과거에 경험했던 유사한 해결 방법을 다시 사용하는 경우가 있다.
    * 이처럼 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 **디자인 패턴**이라고 부른다.
    * 디자인 패턴의 목적은 설계를 재사용하는 것이다.
    * 디자인 패턴은 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음이다.
    * 일단 디자인 패턴을 익히고 나면 변경의 방향과 주기를 이해하는 것만으로도 필요한 역할과 책임, 역할들의 협력 방식을 순간적으로 떠 올릴 수 있게 된다.
* 디자인 패턴이 설계를 재사용하기 위한 것이라면 **프레임워크**는 설계와 코드를 함께 재사용하기 위한 것이다.
    * 프레임워크는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.
    * 프레임워크가 제공하는 아키텍처가 요구사항에 적합하다면 다양한 환경에서 테스트를 거친 견고한 구현 코드를 쉽고 빠르게 재사용할 수 있다.
    * 프레임워크는 각 애플리케이션 요구에 따라 적절하게 커스터마이징할 수 있는 확장 포인트를 제공한다.
* 디자인 패턴과 프레임워크 모두 14장에서 살펴본 일관성 있는 협력과 관련이 있다.
    * 디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공한다.
    * 프레임워크는 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다.
    * 디자인 패턴이 협력을 일관성 있게 만들기 위해 재사용할 수 있는 설계의 묶음이라면, 프레임워크는 일관성 있는 협력을 제공하는 확장 가능한 코드라고 할 수 있다.
    * 결론적으로 디자인 패턴과 프레임워크 모두 협력을 일관성 있게 만들기 위한 방법이다.



## 01 디자인 패턴과 설계 재사용

### 소프트웨어 패턴

* 패턴이란 무엇인가를 논의할 때면 반복적으로 언급되는 몇 가지 핵심적인 특징이 있다.
    * 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
    * 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.
    * 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
    * 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.
* 패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 '아이디어'다.
    * 일반적으로 패턴으로 인정하기 위한 조건으로 '3의 규칙(Rule of Three)'을 언급한다.
    * 이 규칙에 따르면 최소 세 가지 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고 유용한 경우에만 패턴으로 간주할 수 있다.
* 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이다.
    * 패턴은 경험의 산물이다.
    * 책상 위에서 탄생한 이론이나 원리와 달리 패턴은 치열한 실무 현장 역학관계 속에서 검증되고 입증된 자산이다.
    * 따라서 실무 경험이 적은 초보자라고 하더라도 패턴을 익히고 반복적으로 적용하는 과정 속에서 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있게 된다.
* 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 패턴의 '이름'이다.
    * 패턴의 이름은 커뮤니티가 공유할 수 있는 중요한 어휘집을 제공한다.
    * 잘 알려진 이름을 사용함으로써 '인터페이스를 하나 추가하고 이 인터페이스를 구체화하는 클래스를 만든 후 객체의 생성자나 setter 메서드에 할당해서 런타임 시에 알고리즘을 바꿀 수있게 하자'는 장황한 대화가 **STRATEGY** 패턴을 적용하자는 단순한 대화로 바뀐다.
    * 패턴의 이름은 높은 수준의 대화를 가능하게 하는 원천이다.
* 마틴 파울러가 언급한 것처럼 패턴의 범위가 소프트웨어 개발과 직접적인 연관성을 가진 분석, 설계, 구현 영역만으로 한정되는 것은 아니다.
    * 다양한 크기의 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법, 스토리 카드나 백로그를 통해 요구사항을 관리하는 방법과 같이 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이 될 수 있다.
* 패턴은 홀로 존재하지 않는다.
    * 특정 패턴 내에 포함된 컴포넌트와 컴포넌트 간의 관계는 더 작은 패턴에 의해 서술될 수 있으며, 패턴들을 포함하는 더 큰 패턴 내에 통합될 수 있다.
    * 크리스토퍼 알렉산더는 연관된 패턴들의 집합들이 모여 하나의 **패턴 언어(Pattern Language)**를 구성한다고 정의하고 있다.
    * 패턴 언어는 연관된 패턴 카테고리뿐만 아니라 패턴의 생성 규칙과 함께 패턴 언어에 속한 다른 패턴과의 관계 및 협력 규칙을 포함한다.
    * POSA1에서는 패턴 언어라는 용어가 지닌 제약 조건을 완화하기 위해 패턴 시스템이라는 특수한 용어의 사용을 제안하기도 했으나 현재 두 용어는 거의 동일한 의미로 사용되고 있다.



### 패턴 분류

* 패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 **아키텍처 패턴(Architecture Pattern)**, **분석 패턴(Analysis Pattern)**, **디자인 패턴(Design Pattern)**, **이디엄(Idiom)**의 4가지로 분류하는 것이다.
    * 4가지 중에서 가장 널리 알려진 것이 디자인 패턴이다.
    * 디자인 패턴은 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다.
    * 디자인 패턴은 중간 규모의 패턴으로, 특정한 설계 문제를 해결하는 것을 목적으로 하며, 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.
* 디자인 패턴의 상위에는 소프트웨어의 전체적인 구조를 결정하기 위해 사용할 수 있는 **아키텍처 패턴**이 위치한다.
    * 아키텍처 패턴은 미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.
    * 아키텍처 패턴은 구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공하며, 디자인 패턴과 마찬가지로 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.
* 디자인 패턴의 하위에는 **이디엄**이 위치한다.
    * 이디엄은 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴으로, 주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다.
    * 이디엄은 언어에 종속적이기 때문에 특정 언어의 이디엄이 다른 언어에서는 무용지물이 될 수 있다.
    * 예를 들어, 객체가 스스로 자신을 참조하는 객체들의 개수를 카운트해서 더 이상 자신이 참조되지 않을 경우 스스로를 삭제하는 C++의 COUNT POINTER 이디엄은 가상머신이 참조되지 않는 객체를 자동으로 삭제하는 가비지 컬렉션 메커니즘을 가진 자바에서는 유용하지 않다.
* 아키텍처 패턴, 디자인 패턴, 이디엄이 주로 기술적인 문제를 해결하는 데 초점을 맞추고 있다면 **분석 패턴**은 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다.
    * 분석 패턴은 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다.
    * 분석 패턴은 단 하나의 도메인에 대해서만 적절할 수도 있고 여러 도메인에 걸쳐 적용할 수도 있다.



### 패턴과 책임-주도 설계

* 객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 일이다.
    * 책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재사용성 등의 다양한 요소들의 트레이드오프를 통해 결정된다.
    * 가끔씩 책임과 협력을 결정하는 작업이 손쉽게 진행될 때도 있지만 대부분의 경우에는 훌륭한 품질의 설계를 얻기 위해 많은 시간과 노력을 들여야만 한다.
    * 어떤 책임이 필요한가?
    * 이 책임을 어떤 객체에게 할당해야 하는가?
    * 유연하고 확장 가능한 협력 관계를 구축하기 위해서는 객체와 객체 간에 어떤 의존성이 존재해야 하는가?
* 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
    * 패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공한다.
    * <<GoF의 디자인 패턴>>에 정리된 패턴을 예로 들어 설명하면 **STRATEGY** 패턴은다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합으로 제공한다.
    * **BRIDGE** 패턴은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만든다.
    * **OBSERVER** 패턴은 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.
* 여기서 언급한 패턴들의 세부적인 내용이 중요한 것이 아니다.
    * 중요한 것은 패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실이다.
    * 특정한 상황에 적용 가능한 패턴을 잘 알고 있다면 책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 구성할 수 있다.
* 패턴의 구성 요소는 클래스가 아니라 '역할'이다.
    * 예를 들어, 클라이언트가 개별 객체와 복합 객체를 동일하게 취급할 수 있는 COMPOSITE 패턴을 살펴보자.
    * 패턴의 구성 요소인 Component, Composite, Leaf는 클래스가 아니라 협력에 참여하는 객체들의 역할이다.
    * Component는 역할이기 때문에 Component가 제공하는 오퍼레이션을 구현하는 어떤 객체라고 Component의 역할을 수행할 수 있다.
* 패턴을 구성하는 요소가 클래스가 아니라 역할이라는 사실은 패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다는 사실을 암시한다.
* 역할은 동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합을 암시하기 때문에 하나의 객체가 세 가지 역할 모두를 수행하더라도 문제가 없다.
* 반대로 다수의 클래스가 동일한 역할을 구현할 수도 있다.
* 디자인 패턴의 구성요소가 클래스와 메서드가 아니라 역할과 책임이라는 사실을 이해하는 것이 중요하다.
    * 어떤 구현 코드가 어떤 디자인 패턴을 따른다고 이야기할 때는 역할, 책임, 협력의 관점에서 유사성을 공유한다는 것이지 특정한 구현 방식을 강제하는 것은 아니라는 점을 이해하는 것 역시 중요하다.
    * 디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.



### 캡슐화와 디자인 패턴

* 몇가지 이례적인 경우를 제외하면 널리 알려진 대부분의 디자인 패턴은 협력을 일관성 있고 유연하게 만드는 것을 목적으로 한다.
    * 따라서 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의하고 있다.
* 영화 예매 시스템에서 Movie가 DiscountPolicy 상속 계층을 합성 관계로 유지해야 하는 다양한 설계 원칙과 이유에 대해 장황하게 설명했지만 사실 이 설계는 **STRATEGY** 패턴을 적용한 예다.
    * **STRATEGRY** 패턴의 목적은 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 합성을 이용한다.
* 영화에 적용될 할인 정책의 종류는 Movie가 참조하는 DiscountPolicy의 서브클래스가 무엇이야에 따라 결정된다.
    * 그리고 **STRATEGY** 패턴을 이용하면 Movie와 DiscountPolicy 사이의 결합도를 낮게 유지할 수 있기 때문에 런타임에 알고리즘을 변경할 수 있다.
* 물론 변경을 캡슐화하는 방법이 합성만 있는 것은 아니다.
    * 상속을 이용할 수도 있다.
    * 그림 15.5는 Movie의 인터페이스 측면에서는 그림 15.4와 동일하지만 변경을 캡슐화하기 위해 상속을 사용한 예다.
    * 여기서 변하지 않는 부분은 Movie고 변하는 부분은 AmountDiscountMovie와 PercentDiscountMovie다.
    * 그리고 변경하지 않는 부분은 부모 클래스로, 변하는 부분은 자식 클래스로 분리함으로써 변경을 캡슐화한다.
    * 이처럼 알고리즘을 캡슐화하기 위해 합성 관계가 아닌 상속 관계를 사용하는 것을 **TEMPLATE METHOD** 패턴이라고 부른다.
* 추상 클래스나 인터페이스를 사용해 변경을 캡슐화하는 합성과 달리 상속을 사용할 경우에는 추상 메서드를 이용해 변경을 캡슐화해야 한다.
    * calculateDiscountAmount 메서드가 서브클래스의 변경을 캡슐화하기 위해 사용되는 추상 메서드다.
    * 부모 클래스의 calculateFee 메서드 안에서 추상 메서드인 calculateDiscountAmount를 호출하고 자식 클래스들이 이 메서드를 오버라이딩해서 변하는 부분을 구현한다는 것이 중요하다.
    * 이것은 **TEMPLATE METHOD** 패턴의 전형적인 구현 방법이다.
* 이처럼 **TEMPLATE METHOD**패턴은 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화할 수 있는 디자인 패턴이다.
    * 다만 합성보다는 결합도가 높은 상속을 사용했기 때문에 **STRATEGY** 패턴처럼 런타임에 객체의 알고리즘을 변경하는 것은 불가능하다.
    * 하지만 알고리즘 교체와 같은 요구사항이 없다면 상대적으로 **STRATEGY** 패턴보다 복잡도를 낮출 수 있다는 면에서는 장점이라고 할 수 있다.
* 핸드폰 과금 시스템 설계는 **DECORATOR** 패턴을 기반으로 한다.
    * **DECORATOR** 패턴은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로서 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용한다.
    * **DECORATOR** 패턴은 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화할 수 있다.
* 대부분의 디자인 패턴의 목적은 특정한 변경을 캡슐화함으로써 유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유하는 것이다.
    * 디자인 패턴에서 중요한 것은 디자인 패턴의 구현 방법이나 구조가 아니다.
    * 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이 중요하다.
    * 그리고 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지를 이해하는 것이 더 중요하다.



### 패턴은 출발점이다

* 패턴은 출발점이지 목적지가 아니다.
    * 많은 전문가들은 널리 요구되는 유연성이나 공통적으로 발견되는 특정한 설계 이슈를 해결하기 위해 적절한 디자인 패턴을 이용해 설계를 시작한다.
    * 그러나 패턴은 설계의 목표가 돼서는 안된다.
    * 패턴은 단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침판에 불과하다.
    * 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.
* 패턴에 처음 입문한 사람들은 패턴의 강력함에 매료된 나머지 아무리 사소한 설계라도 패턴을 적용해보려고 시도한다.
    * 그러나 명확한 트레이드오프 없이 패턴을 남용하면 설게가 불필요하게 복잡해지게 된다.
* 정당한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이다.
    * 패턴은 복잡성의 가치가 단순성을 넘어설 때만 정당화돼야 한다.
    * 패턴을 적용할 때는 항상 설계를 좀 더 단순하고 명확하게 만들 수 있는 방법이 없는지를 고민해야 한다.
    * 또한 코드를 공유하는 모든 사람들이 적용된 패턴을 알고 있어야 한다.



## 02 프레임워크와 코드 재사용

### 코드 재사용 대 설계 재사용

* 여러 프로젝트나 도메인 사이에 비슷한 문제가 충분히 많이 존재한다면 컴포넌트 기반의 접근법이 효과가 있을 수 있겠지만 애플리케이션과 도메인의 다양성으로 인해 두 가지 문제가 아주 비슷한 경우는 거의 없다고 한다.
    * 따라서 가장 기본이 되는 아주 적은 부분만이 일반화될 수 있을 것이다.
    * 결국 다양한 도메인에 재사용 가능한 컴포넌트라는 개념은 비현실적이라고 할 수 있다.
* 가장 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다.
    * 코드 재사용만을 강조하는 컴포넌트는 실패했다.
    * 추상적인 수준에서의 설계 재사용을 강조하는 디자인 패턴은 재사용을 위해 매번 유사한 코드를 작성해야만 한다.
    * 설계를 재사용하면서도 유사한 코드를 반복적으로 구현하는 문제를 피할 수 있는 방법은 없을까?
    * 이 질문에 대한 객체지향 커뮤니티의 대답이 바로 프레임워크다.
* 프레임워크란 '추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계', 또는 '애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격'을 의미한다.
    * 첫 번째 정의가 프레임워크의 구조적인 측면에 초점을 맞추고 있다면 두 번째 정의는 코드와 설계의 재사용이라는 프레임워크의 사용 목적에 초점을 맞춘다.
* 프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다.
    * 프레임워크는 애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함한다.
    * 또한 애플리케이션을 확장할 수 있도록 부분적으로 구현된 추상 클래스와 인터페이스 집합뿐만 아니라 추가적인 작업 없이도 재사용 가능한 다양한 종류의 컴포넌트도 함께 제공한다.



### 상위 정책과 하위 정책으로 패키지 분리하기

* 프레임워크의 핵심은 추상 클래스나 인터페이스 같은 추상화라고 할 수 있다.
    * 그렇다면 추상 클래스와 인터페이스가 가지는 어떤 특징이 프레임워크의 재사용성을 향상시키는 것일까?
    * 이 질문의 답은 일관성 있는 협력이라는 주제와 관련이 있다.
* 추상 클래스와 인터페이스가 일관성 있는 협력을 만드는 핵심 재료하는 것을 기억하라.
    * 협력을 일관성있고 유연하게 만들기 위해서는 추상화를 이용해 변경을 캡슐화해야 한다.
    * 그리고 협력을 구현하는 코드 안의 의존성은 가급적이며 추상 클래스나 인터페이스와 같은 추상화를 향하도록 작성해야 한다.
* 객체지향 이전의 구조적인 설계와 같은 전통적인 소프트웨어 개발 방법의 경우 상위 레벨 모듈이 하위 레벨 모듈에, 그리고 상위 정책이 구체적인 세부적인 사항에 의존하도록 소프트웨어를 구성한다.
* 하지만 상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경된다.
    * 핸드폰 과금 시스템에서 상위 정책은 요금제가 기본 정책과 부가 정책으로 구성되고, 이 정책들이 다양한 순서로 조합될 수 있다는 점이다.
    * 그에 비해 세부 사항은 시간대별, 요일별 방식, 기간별 방식과 같은 세부적인 정책의 종류다.
    * 만약 변하지 않는 상위 정책이 자주 변하는 세부 사항에 의존한다면 변경에 대한 파급효과로 인해 상위 정책이 불안정해질 것이다.
* 그리고 상위 정책이 세부 사항에 비해 재사용될 가능성이 높다.
    * 기본 정책과 부가 정책을 조합하는 규칙은 모든 요금 계산 시에 재사용돼야 하는 협력 패턴이다.
    * 그에 비해시간대별 방식으로 요금을 계산하거나 세금을 부과하는 것은 특수한 경우에만 사용되는 기본 정책과 부가 정책의 한 예라고 할 수 있다.
* 의존성 역전 원칙의 관점에서 세부 사항은 '변경'을 의미한다.
* 이를 위해 변하는 것과 변하지 않는 것을 서로 분리해야 한다.
    * 여기서 변하지 않는 것은 상위 정책에 속하는 역할들의 협력 구조다.
    * 변하는 것은 구체적인 세부사항이다.
* 이를 위한 첫걸음은 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리하는 것이다.
* 중요한 것은 패키지 사이의 의존성 방향이다.
    * 의존성 역전 원리에 따라 추상화에만 의존하도록 의존성 방향을 조정하고 추상화를 경계로 패키지를 분리했기 때문에 세부 사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야 한다.



### 제어 역전 원리

* 상위 정책을 재사용한다는 것은 결국 도메인에 존재하는 핵심 개념들 사이의 협력 관계를 재사용한다는 것을 의미한다.
    * 객체지향 설계의 재사용은 개별 클래스가 아니라 객체들 사이의 공통적인 협력 흐름으로부터 나온다.
    * 그리고 그 뒤에는 항상 의존성 역전 원리라는 강력한 지원군이 존재한다.
    * 의존성 역전 원리는 전통적인 설계 방법과 객체지향을 구분하는 가장 핵심적인 원리다.
* 의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘이다.
    * 의존성 역전은 의존성의 방향뿐만 아니라 제어 흐름의 주체 역시 역전시킨다.
* 그러나 의존성을 역전시킨 객체지향 구조에서는 반대로 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출한다.
    * 따라서 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다.
    * 즉, 의존성을 역전시키면 제어 흐름의 주체 역시 역전된다.
    * 이를 **제어 역전(Inversion of Control)** 원리, 또는 **할리우드(Hollywood) 원리**라고 한다.
* 프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에서 달라질 수 있는 특정한 동작은 비워둔다.
    * 그리고 이렇게 완성되지 않은 채 남겨진 동작을 훅(hook)이라고 부른다.
    * 훅의 구현 방식은 애플리케이션의 컨텍스트에 따라 달라진다.
    * 훅은 프레임워크 코드에서 호출하는 프레임워크의 특정 부분이다.
    * 재정의된 제어 역전 원리에 따라 프레임워크가 원하는 시점에 호출된다.
* 여기서 협력을 제어하는 것은 프레임워크라는 것에 주목하라.
    * 우리는 프레임워크가 적절한 시점에 실행할 것으로 예상되는 코드를 작성할 뿐이다.
    * 과거의 좋았던 시절에는 우리가 직접 라이브러리 코드를 호출했지만 객체지향 시대에는 그저 프레임워크가 호출하는 코드를 작성해야 한다.
    * 제어가 우리에게는 프레임워크로 넘어가 버린 것이다.
    * 다시 말해서 제어가 역전된 것이다.
* 우리의 코드는 수동적인 존재다.
    * 프레임워크가 우리의 코드를 호출해줄 때까지 그저 넋놓고 기다리고 있을 수밖에 없다.
    * 할리우드에서 캐스팅 담당자가 오디션을 보러 온 배우에게 "먼저 연락하지 마세요, 저희가 연락드리겠습니다"라고 말하는 것처럼 프레임워크는 자신을 찾지 말라고 이야기한다.



