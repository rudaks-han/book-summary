# 15장 디자인 패턴과 프레임워크

* 애플리케이션을 설계하다 보면 어떤 요구사항을 해결하기 위해 과거에 경험했던 유사한 해결 방법을 다시 사용하는 경우가 있다.
    * 이처럼 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 **디자인 패턴**이라고 부른다.
    * 디자인 패턴의 목적은 설계를 재사용하는 것이다.
    * 디자인 패턴은 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음이다.
    * 일단 디자인 패턴을 익히고 나면 변경의 방향과 주기를 이해하는 것만으로도 필요한 역할과 책임, 역할들의 협력 방식을 순간적으로 떠 올릴 수 있게 된다.
* 디자인 패턴이 설계를 재사용하기 위한 것이라면 **프레임워크**는 설계와 코드를 함께 재사용하기 위한 것이다.
    * 프레임워크는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.
    * 프레임워크가 제공하는 아키텍처가 요구사항에 적합하다면 다양한 환경에서 테스트를 거친 견고한 구현 코드를 쉽고 빠르게 재사용할 수 있다.
    * 프레임워크는 각 애플리케이션 요구에 따라 적절하게 커스터마이징할 수 있는 확장 포인트를 제공한다.
* 디자인 패턴과 프레임워크 모두 14장에서 살펴본 일관성 있는 협력과 관련이 있다.
    * 디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공한다.
    * 프레임워크는 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다.
    * 디자인 패턴이 협력을 일관성 있게 만들기 위해 재사용할 수 있는 설계의 묶음이라면, 프레임워크는 일관성 있는 협력을 제공하는 확장 가능한 코드라고 할 수 있다.
    * 결론적으로 디자인 패턴과 프레임워크 모두 협력을 일관성 있게 만드릭 위한 방법이다.



## 01 디자인 패턴과 설계 재사용

### 소프트웨어 패턴

* 패턴이란 무엇인가를 논의할 때면 반복적으로 언급되는 몇 가지 핵심적인 특징이 있다.
    * 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
    * 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.
    * 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
    * 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.
* 패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 '아이디어'다.
    * 일반적으로 패턴으로 인정하기 위한 조건으로 '3의 규칙(Rule of Three)'을 언급한다.
    * 이 규칙에 따르면 최소 세 가지 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고 유용한 경우에만 패턴으로 간주할 수 있다.
* 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이다.
    * 패턴은 경험의 산물이다.
    * 책상 위에서 탄생한 이론이나 원리와 달리 패턴은 치열한 실무 현장 역학관계 속에서 검증되고 입증된 자산이다.
    * 따라서 실무 경헙이 적은 초보자라고 하더라도 패턴을 익히고 반복적으로 적용하는 과정 속에서 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있게 된다.
* 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 패턴의 '이름'이다.
    * 패턴의 이름은 커뮤니티가 공유할 수 있는 중요한 어휘집을 제공한다.
    * 잘 알려진 이름을 사용함으로써 '인터페이스를 하나 추가하고 이 인터페이스를 구체화하는 클래스를 만든 후 객체의 생성자나 setter 메서드에 할당해서 런타임 시에 알고리즘을 바꿀 수있게 하자'는 장황한 대화가 **STRATEGY** 패턴을 적용하자는 단순한 대화로 바뀐다.
    * 패턴의 이름은 높은 수준의 대화를 가능하게 하는 원천이다.
* 마틴 파울러가 언급한 것처럼 패턴의 범위가 소프트웨어 개발과 직접적인 연관성을 가진 분석, 설계, 구현 영역만으로 한정되는 것은 아니다.
    * 다양한 크기의 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법, 스토리 카드나 백로그를 통해 요구사항을 관리하는 방법과 같이 반복적인 규칙을 발견한 수 있는 모든 영역이 패턴의 대상이 될 수 있다.
* 패턴은 홀로 존재하지 않는다.
    * 특정 패턴 내에 포함된 컴포넌트와 컴포넌트 간의 관계는 더 작은 패턴에 의해 서술될 수 있으며, 패턴들을 포함하는 더 큰 패턴 내에 통합될 수 있다.
    * 크리스토퍼 알렉산더는 연관된 패턴들의 집합들이 모여 하나의 **패턴 언어(Pattern Language)**를 구성한다고 정의하고 있다.
    * 패턴 언어는 연관된 패턴 카테고리뿐만 아니라 패턴의 생성 규칙과 함께 패턴 언어에 쏙한 다른 패턴과의 관계 및 협력 규칙을 포함한다.
    * POSA1에서는 패턴 언어라는 용어가 지닌 제약 조건을 완화하기 위해 패턴 시스템이라는 특수한 용어의 사용을 제안하기도 했으나 현재 두 용어는 거의 동일한 의미로 사용되고 있다.



### 패턴 분류

* 패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 **아키텍처 패턴(Architecture Pattern)**, **분석 패턴(Analysis Pattern)**, **디자인 패턴(Design Pattern)**, **이디엄(Idiom)**의 4가지로 분류하는 것이다.
    * 4가지 중에서 가장 널리 알려진 것이 디자인 패턴이다.
    * 디자인 패턴은 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다.
    * 디자인 패턴은 중간 규모의 패턴으로, 특정한 설계 문제를 해결하는 것을 목적으로 하며, 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.
* 디자인 패턴의 상위에는 소프트웨어의 전체적인 구조를 결정하기 위해 사용할 수 있는 **아키텍처 패턴**이 위치한다.
    * 아키텍처 패턴은 미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.
    * 아키텍처 패턴은 구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공하며, 디자인 패턴과 마찬가지로 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.
* 디자인 패턴의 하위에는 **이디엄**이 위치한다.
    * 이디엄은 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴으로, 주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다.
    * 이디엄은 언어에 종속적이기 때문에 특정 언어의 이디엄이 다른 언어에서는 무용지물이 될 수 있다.
    * 예를 들어, 객체가 스스로 자신을 참조하는 객체들의 개수를 카운트해서 더 이상 자신이 참조되지 않을 경우 스스로를 삭제하는 C++의 COUNT POINTER 이디엄은 가상머신이 참조되지 않는 객체를 자동으로 삭제하는 가비지 컬렉션 메커니즘을 가진 자바에서는 유용하지 않다.
* 아키텍처 패턴, 디자인 패턴, 이디엄이 주로 기술적인 문제를 해결하는 데 초점을 맞추고 있다면 **분석 패턴**은 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다.
    * 분석 패턴은 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다.
    * 분석 패턴은 단 하나의 도메인에 대해서만 적절할 수도 있고 여러 도메인에 걸쳐 적용할 수도 있다.



### 패턴과 책임-주도 설계

* 객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 일이다.
    * 책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재사용성 등의 다양한 욧소들의 트레이드오프를 통해 결정된다.
    * 가끔씩 책임과 협력을 결정하는 작업이 손쉽게 진행될 때도 있지만 대부분의 경우에는 훌륭한 품질의 설계를 얻기 위해 많은 시간과 노력을 들여야만 한다.
    * 어떤 책임이 필요한가?
    * 이 책임을 어떤 객체에게 할당해야 하는가?
    * 유연하고 확장 가능한 협력 관계를 구축하기 위해서는 객체와 객체 간에 어떤 의존성이 존재해야 하는가?
* 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
    * 패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공한다.
    * <<GoF의 디자인 패턴>>에 정리된 패턴을 예로 들어 설명하면 **STRATEGY** 패턴은다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합으로 제공한다.
    * **BRIDGE** 패턴은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만든다.
    * **OBSERVER** 패턴은 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.
* 여기서 언급한 패턴들의 세부적인 내용이 중요한 것이 아니다.
    * 중요한 것은 패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실이다.
    * 특정한 상황에 적용 가능한 패턴을 잘 알고 있다면 책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 구성할 수 있다.
* 패턴의 구성 요소는 클래스가 아니라 '역할'이다.
    * 예를 들어, 클라이언트가 개별 객체와 복합 객체를 동일하게 취급할 수 있는 COMPOSITE 패턴을 살펴보자.
    * 패턴의 구성 요소인 Component, Composite, Leaf는 클래스가 아니라 협력에 참여하는 객체들의 역할이다.
    * Component는 역할이기 때문에 Component가 제공하는 오퍼레이션을 구현하는 어떤 객체라고 Component의 역할을 수행할 수 있다.
* 패턴을 구성하는 요소가 클래스가 아니라 역할이라는 사실은 패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다는 사실을 암시한다.
* 역할은 동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합을 암시하기 때문에 하나의 객체가 세 가지 역할 모두를 수행하더라도 문제가 없다.
* 반대로 다수의 클래스가 동일한 역할을 구현할 수도 있다.
* 디자인 패턴의 구성요소가 클래스와 메서드가 아니라 역할과 책임이라는 사실을 이해하는 것이 중요하다.
    * 어떤 구현 코드가 어떤 디자인 패턴을 따른다고 이야기할 때는 역할, 책임, 협력의 관점에서 유사성을 공유한다는 것이지 특정한 구현 방식을 강제하는 것은 아니라는 점을 이해하는 것 역시 중요하다.
    * 디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.



### 캡슐화와 디자인 패턴





### 패턴은 출발점이다





## 02 프레임워크와 코드 재사용

### 코드 재사용 대 설계 재사용





### 상위 정책과 하위 정책으로 패키지 분리하기





### 제어 역전 원리

