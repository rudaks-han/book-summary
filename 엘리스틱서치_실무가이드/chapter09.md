# 09 엘라스틱서치와 루씬 이야기

## 9.1 클러스터 관점에서 구성요소 살펴보기

* 엘라스틱서치는 기본적으로 클러스터라는 단위로 데이터를 제공한다.
* 각 노드는 모두 색인 및 검색 기능을 제공하는 일종의 물리적인 서버이기도 하다.
* 내부에는 루씬 라이브러리가 있다.



### 9.1.1 클러스터

* 클러스터는 데이터를 실제로 가지고 있는 노드의 모음이다.
* 관련된 모든 노드들을 논리적으로 확장해서 클러스터라고 부른다.
* 같은 클러스터 내부의 데이터만 서로 공유가 가능하다.



### 9.1.2 노드

* 물리적으로 실행된 런타임 상태의 엘라스틱서치를 노드라고 부른다.
* 엘라스틱서치 인스턴스를 노드라고 한다.
* 노드는 논리적인 클러스터를 이루는 구성원의 일부이다.



### 9.1.3 인덱스

* 인덱스는 유사한 특성을 가지고 있는 문서를 모아둔 문서들의 컬렉션이다.

* 인덱스명은 모두 소문자로 설정해야 한다.

    

> 루씬 인덱스
>
> 루씬에서는 전문(Full-Text)을 분석하고 분석된 결과를 물리적인 디스크로 저장한다. 이러한 과정을 루씬 입장에서는 색인(indexing) 과정이라고 부른다. 이 과정에 의해 생성된 데이터를 인덱스라고 하기 때문에 엘라스틱서치 인덱스와 잘 구분해서 이해해야 한다.



### 9.1.4 문서

* 문서는 검색 대상이 되는 실제 물리적인 데이터를 뜻한다.
* 문서는 인덱스를 생성할 수 있는 기본적인 정보 단위이고 엘라스틱서치에서는 JSON 형식으로 표현된다.



### 9.1.5 샤드

* 일반적으로 하드웨어에서 제공되는 리소스 이상의 데이터를 저장할 수 없지만 물리적인 한계를 뛰어넘기 위해 샤드라는 개념을 도입했다.
* 인덱스에 쿼리를 요청하면 인덱스가 가지고 있는 모든 샤드로 검색 요청이 전달되고 각 샤드에서 1차적으로 검색이 이뤄진 후 그 결과를 취합해서 최종 결과로 제공한다.



> 샤딩이 중요한 이유
>
> 1. 지속적으로 증가하는 콘텐츠가 수평적으로 분할되어 하드웨어의 한계를 극복할 수 있다.
> 2. 여러 노드에서 샤드를 통해 분산 처리되므로 성능이나 처리량을 향상시킬 수 있다.



### 9.1.6 레플리카

* 샤드의 복제본을 레플리카(Replica)라고 한다.
* 레플리카를 이용한 페일오버 메커니즘을 제공하고 있고 이를 이용해 안정적인 클러스터 운영을 보장한다.



### 9.1.7 세그먼트

* 샤드 내부에는 루씬 라이브러리를 포함하고 있는데, 이를 이용해 대부분의 검색 기능을 제공한다.
* 루씬에 데이터가 색인되면 데이터는 최소한의 단위인 토큰으로 분리되고 특수한 형태의 자료구조로 저장되는데 이렇게 저장된 자료구조를 `세그먼트`라고 한다.



## 9.2 엘라스틱서치 샤드 vs. 루씬 인덱스

* 엘라스틱서치는 루씬 라이브러리를 샤드 내부에 가지고 있으며, 이 루씬 라이브러리가 핵심 모듈이라고 설명했다.
* 루씬은 다수의 클래스로 구성돼 있는 검색 라이브러리이고, 이중 가장 중요한 클래스가 바로 IndexWriter와 IndexSearcher이다.



* 루씬 인덱스 내부에는 세그먼트라는 특수한 자료구조가 다수 존재한다.
* 루씬 인덱스는 세그먼트를 이용해 검색을 수행한다.
* 루씬 인덱스는 자기 자신이 가지고 있는 세그먼트 내에서만 검색이 가능하다는 것과 달리 샤드는 모든 샤드가 가지고 있는 세그먼트들을 논리적으로 통합해서 검색할 수 있다.



> **세그먼트**
>
> * 루씬 내부에 존재하는 자료구조다.
> * 역색인 구조로 생성되어 읽기에 최적화돼 있다.
> * 하나의 루씬 내부에서만 존재할 수 있고 확장이 불가능하다.
>
> **루씬 인덱스**
>
> * 검색과 색인 기능을 가진 쵷소한의 검색엔진이다.
> * IndexWriter로 색인 과정을 통해 세그먼트를 생성한다.
> * IndexSearcher를 이용해 세그먼트를 검색한다.
> * 자신이 가진 세그먼트 내에서만 검색이 가능하다.
>
> **엘라스틱서치 샤드**
>
> * 엘라스틱서치에서 제공하는 가장 작은 단위의 검색엔진이다.
> * 내부적으로 루씬을 확장해서 검색엔진 역할을 수행한다.
> * 다수의 샤드가 협력해서 존재하는 모든 세그먼트를 검색할 수 있다.



## 9.3 엘라스틱서치가 근실시간 검색을 제공하는 이유

엘라스틱서치에서는 색인과 검색이 매우 빠르게 일어나는데, 색인 결과가 물리적인 디스크에 생성되는데도 불구하고 사용자에게 실시간에 가까운 검색이 제공될 수 있는 이유는 무엇일까?



### 9.3.1 색인 작업 시 세그먼트의 기본 동작 방식

* 세그먼트는 역색인 구조를 지닌 파일 자체를 의미하는데 세그먼트 내부에는 실제로 색인된 데이터가 역색인 구조로 저장돼 있다.
* 루씬에는 세그먼트들을 관리하기 위한 용도로 커밋 포인트라는 자료구조를 제공한다.
* 루씬의 IndexSearcher는 검색 요청 시 커밋 포인트를 이용해 가장 오래된 세그먼트부터 차례로 검색한 후 각 결과를 하나로 합쳐서 제공한다.
* 최초 색인 작업 요청이 루씬에 들어오면 IndexWriter에 의해 색인 작업이 이뤄지고 결과물로 하나의 세그먼트가 생성된다.
* 그 후 색인 작업이 추가로 요청될 때마다 새로운 세그먼트가 추가로 생성되고 커밋포인트에 기록된다.
* 색인 작업이 일어날 때마다 이런 식으로 세그먼트의 개수는 점점 늘어난다.
* 너무 많은 세그먼트가 생성되면 읽기 성능이 저하될 수 있기 때문에 루씬은 백그라운드에서 주기적으로 세그먼트 파일을 병합하는 작업을 수행하고 이를 통해 모든 세그먼트들을 물리적으로 하나의 파일로 병합한다.

루씬에 데이터 추가 작업이 요청되면 IndexWriter는 다음과 같이 동작한다.

##### (1) 최초 색인이 요청된 경우

1. IndexWriter가 세그먼트를 생성한다.
2. IndexSearcher가 생성된 세그먼트를 읽어 검색을 제공한다.

##### (2) 추가 색인이 요청된 경우

1. IndexWriter가 세그먼트를 추가 생성한다.
2. 세그먼트가 추가 생성되는 동안 기존 세그먼트만 읽어 검색 결과를 제공한다.
3. 세그먼트 생성이 완료되면 생성된 모든 세그먼트를 읽어 검색결과를 제공한다.

##### (3) 주기적으로 세그먼트 Merge 작업이 일어날 경우

1. IndexWriter가 Merge 대상이 되는 세그먼트들을 복제한다.
2. IndexWriter가 복제한 세그먼트들을 하나의 세그먼트로 합친다.
3. 복제된 세그먼트들이 하나로 합쳐지는 동안 IndexSearcher는 원본 세그먼트를 읽어 검색 결과를 제공한다.
4. 복제본 통합 작업이 완료되면 원본 세그먼트와 교체하고 교체된 원본 세그먼트들은 삭제한다.
5. IndexSearcher는 새로운 세그먼트를 읽어 검색 결과를 제공한다.



### 9.3.2 세그먼트 불변성

* 루씬에서 수정을 허용하지 않는 세그먼트의 이러한 동작 방식을 불변성이라고 부른다.

    

* 세그먼트 불변성의 여러 가지 장점

    * 동시성 문제를 회피할 수 있다.
    * 시스템 캐시를 적극적으로 활용할 수 있다.
    * 높은 캐시 적중률을 유지할 수 있다.
    * 리소스를 절감할 수 있다.

* 단점

    * 수정이 불가능하다는 점
    * 일부 데이터가 변경되더라도 전체 역색인 구조가 다시 만들어져야 한다.
    * 실시간 반영이 상대적으로 어려워진다.
    * 변경사항을 반영하려면 역색인을 새롭게 만드는 작업이 동반되어야 하는데 변경이 많은 경우 실시간 반영 자체가 불가능해진다.

* 이러한 단점을 극복하기 위해 루씬에서는 다수의 세그먼트를 생성해서 제공하는 방식을 택했다.
* 변경이 일어날 때마다 세그먼트를 다시 만드는 것이 아니라 기존 세그먼트를 그대로 두고 추가로 세그먼트를 생성하는 것이다.
* 그리고 검색 요청 시 생성된 모든 세그먼트를 읽어서 검색 결과를 제공한다.
* 상대적으로 읽기 연산의 비중이 큰 루씬에서는 세그먼트에 불변성을 부여함으로써 읽기 연산의 성능을 대폭 끌어올릴 수 있었다.



### 9.3.3 세그먼트 불변성과 업데이트

* 수정 연산의 경우 세그먼트의 불변성을 유지하기 위해 해당 데이터를 삭제한 후 다시 추가하는 방식으로 동작한다.
* 기존 데이터는 삭제 처리되어 검색 대상에서 제외되고 변경된 데이터는 새로운 세그먼트로 추가되어 검색 대상에 포함된다.
* 수정 연산이지만 내부적으로는 삭제 후 추가하는 방식을 사용함으로써 불변성을 지키면서도 검색엔젠에 수정 기능을 부여할 수 있는 것이다.
* 삭제 연산도 단순히 데이터를 삭제하는 것이 아니다. 
* 사실 모든 문서에는 삭제 여부를 표시하는 비트 배열이 내부적으로 존재하는데, 삭제 요청이 들어오면 삭제될 대상 데이터의 비트 배열을 찾아 삭제여부만 표시하고 끝낸다.
* 그렇다면 검색 시 삭제 표시된 데이터는 어떻게 될까?
* 비트 배열에 삭제 여부만 표시했기 때문에 실제 데이터는 여전히 세그먼트 내부에 물리적으로 남아있다.
* 하지만 검색 시 비트 배열에 설정된 삭제여부 값을 항상 먼저 판단하기 때문에 불변성을 훼손하지 않고도 빠르게 검색 대상에서 제외시킬 수 있다.



루씬에 데이터 수정 작업이 요청되면 IndexWriter는 다음과 같이 동작한다.

##### (1) 세그먼트에서 일부 데이터가 삭제될 경우

1. 루씬은 삭제될 데이터가 포함된 세그먼트의 삭제 여부 비트 배열을 확인한다.
2. 삭제 여부 비트 배열의 flag를 삭제로 표시한다.
3. 세그먼트에 직접적인 변경사항은 없으므로 세그먼트의 불변성을 해치치 않으며 캐시도 그대로 유지된다.
4. IndexSearcher는 검색 작업 시 삭제 여부 비트 배열을 항상 먼저 확인하고 삭제 여부가 체크된 데이터를 검색 결과에서 제외한다.

##### (2) 세그먼트에서 일부 데이터가 수정될 경우

1. 앞의 작업(세그먼트에서 일부 데이터가 삭제될 경우)으로 삭제 처리를 먼저 수행한다.
2. 수정된 데이터를 새로운 세그먼트로 생성한다.
3. IndexSearcher는 모든 세그먼트를 읽어 검색 결과를 제공한다.



* 삭제될 데이터가 실제 물리적으로 삭제되는 시점은 언제일까?
* 바로 백그라운에서 주기적으로 일어나는 Merge 작업이 수행될 때다.
* 루씬이 삭제 데이터를 바로 삭제하지 않고 Merge 작업을 통해 실행하는 이유는 내부의 세그먼트가 가지는 역색인 구조와 관련이 깊다.
* 문서를 하나 삭제하려면 전체 역색인 구조를 뒤져서 관련된 모든 텀을 제거해야 하기 때문에 세그먼트를 다시 생성하는 것과 별반 다를 바가 없어지낟. 
* 그래서 즉시 삭제하는 것이 아니라 주기적으로 세그먼트가 재생성되는 Merge 작업을 기다렸다가 물리적인 삭제 처리를 함께 진행하는 것이다.





















