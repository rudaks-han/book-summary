# 1장. 모놀리식 지옥에서 벗어나라

FTGO의 CTO인 메리의 고민
 
* 개발팀이 주요 릴리스 날짜를 못맞추게 된 이유 고민
* 모놀리식 지옥에 빠져 고통받는 사례
* 마이크로서비스 아키텍처 및 최신 개발방법론이 왠지 먼 나라 이야기처럼 들림

## 1.1 서서히 모놀리식 지옥에 빠져들다.

FTGO는 무슨 회사?

* 온라인 음식 배달업체
* 소비자가 웹사이트/모바일앱에서 주문 -> 음식 픽업하여 소비자에게 배달
* 배달원과 음식점에 대금 지불(스트라이프), 메뉴 편집, 메시지 전송(트릴리오), 이메일 전송(AWS SES)
* 시간이 지날수록 애플리케이션은 복잡해지고 진흙탕집(Big Ball of Mud)패턴으로 변함 -> [참고 링크](https://m.blog.naver.com/PostView.nhn?blogId=muchine98&logNo=220253889434&proxyReferer=https:%2F%2Fwww.google.com%2F)

### 1.1.1 FTGO 애플리케이션 아키텍처
코어가 비즈니스 로직으로 구성된 육각형 아키텍처(hexagonal architecture), port/adapter 아키텍처
- outbound adapter (db access, 외부 서비스 호출)
- inbound adapter (rest api)

논리적으로는 모듈화한 아키텍처이지만 애플리키에션은 WAR 파일 하나로 패키징 한다.

https://getoutsidedoor.com/2018/09/03/ports-adapters-architecture/

![hexogonal archtecture](https://getoutsidedoor.com/wp-content/uploads/2018/09/hexagonal-arch-3-hexagon2.png)

### 1.1.3 모놀리식 지옥의 실상
FTGO는 왜 모놀리식 지옥에 빠져 있는 것일까요?

1. 너무 복잡해서 개발자가 주눅이 든다.
    * 이해할 수 없을 정도로 내용이 방대하고 버그 고치고 새 기능을 구현하기 힘들고 오래 걸린다.
    * 메리는 컨퍼런스에서 jar파일 수천개의 디펜던시를 분석하는 툴의 개발자를 알게 됨. 뭔가 성과(?) --> **결국 MSA로 갈아타는 것이 낫다.**
2. 개발이 더디다.
    * IDE 실행속도도 느리고 빌드 시간도 오래 걸린다.
3. 커밋부터 배포에 이르는 길고 험난한 여정
    * 배포는 한달에 한번
    * 테스트 시간 오래 걸림 (한 사이클 2~3일)
4. 확장하기 어렵다.
    * 리소스 사용형태가 다르다. (예: RAM vs CPU)
5. 모놀리스는 확실하게 전달하기 어렵다. --> 신뢰성 보장 어려움
    * 특정 모듈의 메모리 누수로 인한 시스템 전체 다운
6. 갈수록 한물간 기술 스택에 발목이 붙잡히다.
    * 기술 변경이 어렵다.
    * 점차 안쓰는 기술스택으로 울며 겨자 먹기로 유지
    
## 1.4 마이크로 서비스 아키텍처가 답이다
마이크로 서비스의 기준? 
아주 작은(코드 주 수가 100 미만) 서비스?, 개발하는 데 2주?

필자는 확장 큐브라는 3차원 확장 모델

![확장 큐브](https://thebook.io/img/007035/038_1.jpg)

**X축 확장**: 다중 인스턴스에 고루 요청 분산

부하분산기 뒤에 인스턴스를 N개 띄워 놓고 요청을 분배

![X축](https://thebook.io/img/007035/038_2.jpg)


**Z축 확장**: 요청 속성별 라우팅

요청 헤더에 포함된 userId를 보고 N개의 동일한 애플리케이션 중 선택

![Z축](https://thebook.io/img/007035/039.jpg)

**Y축 확장**: 기능에 따라 서비스로 분해

기능 분해

![Z축](https://thebook.io/img/007035/040.jpg)

### 1.4.2 마이크로서비스는 모듈성을 갖고 있다.
여러 사람이 이해하고 개발할 수 있게 여러 모듈로 분해한다.
마이크로서비스 아키텍처는 서비스를 모듈성의 단위로 사용한다. 각 서비스간에는 API라는 경계로 구분

### 1.4.3 서비스마다 DB가 따로 있다.
여기서 DB는 database라는 개념보다는 store의 개념이다.

### 1.5.1 마이크로서비스 장점
1. 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있다.
    * 테스트성: 자동화 테스트
    * 배포성: 자신이 담당한 서비스 변경분 배포
    * 자율성, 느슨한 결합: 독립적으로 개발, 배포, 확장 가능
2. 서비스가 작아 관리하기 용이하다.
    * 개발자가 코드를 이해하기 쉽다. 생산성 올라감
3. 서비스를 독립적으로 배포/확장할 수 있다.
    * 리소스 요건에 따라 하드웨어 배포 가능
4. 결함 격리가 잘 된다.
    * 메모리 누수에도 다른 서비스 영향 없음
5. 신기술을 시험/도입하기 쉽다.
    1. 언어, 기술 선택이 자유롭다.

### 1.5.2 마이크로서비스 단점
1. 딱 맞는 서비스를 찾기가 쉽지 않다.
    * 서비스 분해에 정해진 규칙이 없다.
2. 분산 시스템은 복잡하다.
    * IPC는 메서드 호출보다 복잡
    * 사용불능, 지연시간, 부분실패 서비스 처리
    * 트랜잭션, 여러서비스 데이타 조회 고려
    * IDE툴, 서비스간 테스트 자동화
3. 여러 서비스에 걸친 공통 기능은 배포할 때 잘 살펴야 한다.
    * 서비스 배포 계획 필요
4. 도입 시기를 결정하기 어렵다.
    * 모놀리식 -> 마이크로서비스로 개발하는 것이 좋다.
    
## 1.6 마이크로서비스 아키텍처 패턴 언어

### 1.6.1 마이크로서비스 아키텍처도 만병통치약은 아니다.
* 생산성 10배인 기법/기술 같은 것은 없다.
* 동기/리액티브, 객체지향/함수형, 자바/자바스크립트, REST/메시징
* 무조건 마이크로서비스로 해야 한다는 것은 아니다.

### 1.6.2 패턴 및 패턴 언어
* 패턴이란 특정 상황에 발생한 문제에 대한 재사용 가능한 해법
* 전략 패턴
* 상용 패턴 구조
    * 강제 조항 (forces)
    * 결과 맥락 (resulting context)
    * 연관 패턴 (related patterns)
    
1. 강제 조항: 문제 해결을 위해 반드시 처리해야 할 이슈
* 어느 조항이 더 중요한지 맥락에 따라 다르므로 욱선순위를 정행 ㅑ한다.
* 코드는 이해학 쉬워야 하는 동시에 성능도 우수해야 한다. --> 리액티브 스타일 코드는 성능은 우수하지만 개발자가 이해하기 어렵다.

2. 결과 맥락: 패턴 적용 결과
* 장점: 패턴의 좋은 점
* 단점: 패턴의 나쁜 점
* 이슈: 패턴 적용 시 발생한 새로운 문제점

3. 연관 패턴: 다섯 가지 관계 유형
* 선행자: 이 패턴을 필요하게 만든 선행 패턴. 마이크로서비스 패턴은 모놀리식 아키텍처 패턴을 제외한 나머지 패턴들의 선행자이다.
* 후행자: 이 패턴으로 야기된 이슈를 해결하는 패턴. 마이크로서비스 패턴을 적용하려면 서비스 디스커버리, 회로 차단기 패턴 등을 적용해야 한다.
* 대안: 이 패턴의 대체 솔루션을 제공하는 패턴 (msa or monolith)
* 일반화: 문제를 해결하는 일반적인 솔루션에 해당하는 패턴
* 세분화: 특벙 패턴을 더 세부적으로 나타낸 형
 

### 1.6.3 마이크로서비스 아키텍처 패턴 언어 개요
1. 인프라 패턴: 주로 개발 영역 밖의 인프라 문제 해결
    * 배포, 디스커버리, 외부 API
2. 애플리케이션 인프라: 개발에도 영향을 미치는 인프라 문제를 해결
    * 횡단 관심사, 보안, 트랜잭셔널 메시징, 통신 스타일, 신뢰성, 관측성
3. 애플리케이션 패턴: 개발자가 맞닥뜨리는 문제를 해결
    * 분해, DB 아키텍처, 쿼리, 데이터 일관성 유지, 테스트

1. 애플리케이션을 여러 서비스로 분해하는 패턴
    1. 비즈니스 능력에 따라 분해
    2. 하위 도메인에 따라 분해
2. 통신 패턴
    1. 통신 스타일: 어떤 종류의 IPC를 사용하는가?
        * 메시징/원격 프로시저 호출
    2. 디스커버리: 서비스의 IP주소를 어떻게 가져오는가?
        * 서비스 레지스트리
    3. 신뢰성: 서비스 불능 시 서비스간 통신의 신뢰성은 어떻게 보장?
        * 회로 차단기
    4. 트랜잭셔널 메시징: DB 트랜잭션에 메시지 송신하고 이벤트 발행하는 행위를 어떻게 통합
    5. 외부 API: 애플리케이션 클라이언트는 서비스와 어떻게 통신하는가?
        * API Gateway/BFF (Back-end for Front-end)
        * [BFF pattern 링크](https://medium.com/@giljae/back-end-for-front-end-pattern-bff-4b73f29858d6)
3. 트랜잭션 관리를 위한 데이터 일관성 패턴
    * 2PC/Saga
4. 데이터 쿼리 패턴
    * API 조합(Composition) / CQRS(Command Query Responsibility Segregation)
5. 서비스 배포 패턴
    * VM이나 컨테이너에 배포/서버리스 방식
6. 관측성 패턴
    * 헬스 체크 API
    * 로그 수집
    * 분산 추적
    * 예외 추적
    * 애플리케이션 지표
    * 감사 로깅
7. 서비스 테스트 자동화 패턴
    * 컨슈머 주도 계약 테스트
    * 컨슈머 쪽 계약 테스트
    * 서비스 컴포넌트 테스트
8. 횡단 관심사 처리 패턴
    * 마이크로서비스 섀시 패턴(Microservice Chassis)
9. 보안 패턴
    * JWT
    
### 프로세스와 조직
* 팀당 인원: 8~12명 (2 pizza)
* 콘웨이 법칙: 애플리케이션 아키텍처는 그것을 개발하는 조직의 구조를 그대로 반영한다.

---
### [Q&A]

> Q. 처음부터 msa 방식을 사용하는 것이 좋을까요? 어차피 시스템은 거대해지고 확대될 것으로 예상이 된다면.. (34 page)

* 이 책 534p에 마이크로서비스로 리팩터링 하는 방법이 나와있다.
* 여러분이 개발 책임자라면 EER의 차기버전을  MSA로 갈 것인가? 아님 모노리스로 할 것인가?
    * 비즈니스 문제를 마이크로 서비스로 해결할 수 있을 때만 마이크로서비스를 도입을 해야 한다.
* 완전히 뜯어 고치기 보다는 단계적으로 리팩터링 하는 것이 좋다.
    * 전체 구조에서 비즈니스적으로 문제가 되는 부분(가치가 있는)을 뽑아서 선택적으로 서비스로 구현한다. --> 결국 단계적으로 모두 서비스로 대체된다.
    * 이런 형태를 strangler 패턴이라고 한다.

* 모노리스 -> 마이크로 서비스 전략
    1. 새 기능을 서비스로 구현한다.
        * 새로 작성되는 코드는 서비스로 구현하라.
        1.1.새 서비스를 모놀리스에 연계
            * API 게이트웨이: 새 기능 요청은 새 서비스로, 기존 요청은 모놀리스로 라우팅
            * 통합 글루 코드(integration glue code): 서비스가 모놀리스 데이터에 접근하고 모놀리스에 구현된 기능을 호출할 수 있게 서비스를 모놀리스에 통합 (REST-API, 도메인 이벤트) 
    2. 표현 계층과 백엔드를 분리한다.
        * 표현 계층, 비즈니스 로직, 데이터 접근 로직 분리
    3. 기능을 여러 서비스로 추출한다.
        * 모놀리스가 가진 비즈니스 능력을 하나씩 서비스로 옮기는 분해 전략을 구사해야 한다.
        3.1 도메인 모델 분리
        3.2 DB 리팩터링
        3.3 변경 범위를 줄이기 위해 데이타를 복제

> Q. 모놀리식, ms 각각이 예를들면 어떤 시스템에 어울릴까요? (34 page)

어떤 시스템이라기 보다는 어떤 비즈니스 요구사항인지? 조직구성, 일정의 영향으로 분리하는 것이 맞을 것 같다.

[모놀리스]
* 작은팀
* mvp version 신제품
* 자본금이 많지 않음
* 주요기능에 대한 성능병목 현상이 없음
* microservice가 유행이라고 생각

[마이크로서비스]
* 연구, 아키텍처 계획을 필요로 하는 일정이 없는 경우
* 다양한 언어에 대한 지식을 가진 팀이 있는 경우
* 확장성, 신뢰성에 대한 고민
* 몇개의 개발 부서가 있는 경우
* 기존 모놀리스 앱이 있고 여러 microservice에 분리될 수 있는 application이 있는 경우

참고자료: https://dev.to/alex_barashkov/microservices-vs-monolith-architecture-4l1m


> Q. attic의 경우 share를 통해 어차피 각 서비스는 share를 dependency 하고 있으니 아무리 서비스가 분리되어 있다고 해도 share에 대한 지속적 배포 위험성과 테스트는 복잡할 수 있지 않을까요? (34 page)

microservice에서 shared library는 결국 없어지거나 최소화 되어야 한다.
attic에서도 shared를 사용하고 있지만 business 영역이 아닌 기술단위로만 사용되고 있다.

아래 내용은 shared library 사용에 대한 blog글이니 참고

https://phauer.com/2016/dont-share-libraries-among-microservices/

* microservice간 shared library를 사용하지 마라
    * 공통코드를 library로 뽑아내는 것은 최선의 선택인것 같다.
    * 재사용성은 빠른 개발을 할수 있다?
    * 하지만 micoservice에서는 서비스간 결합도를 증가시킨다.
* TL;DR
    * 단기간에 개발속도 향상시키지만 결국 coupling을 증가시킨다.
    * 결국 개발속도 증가, 코디네이션 노력, 현대화 방해
    * business logic, model에 shared library를 사용하지 마라.
    * 대신 중복. shared service or service를 더 쪼개라.
* Drawbacks
    * microservice의 큰 장점은 서비스간 독립성이다. (개발, 조합, 기술)
    * 다른 서비스의 변화, 릴리스와 무관하게 진행 가능함.
    * 2개의 서비스가 library를 공유한다면 더 이상 독립적이지 않다.
* Increased Coordination
    * library 작업은 팀간 협업이 필요하다. 이로 인해 개발속도가 느려진다.
    * library 변화가 모든 microservice에 변화를 필요로 한다.
* Errors and Side-Effects
    * library의 변화는 필요하지 않은 서비스에도 영향을 준다. (error, side effect)
* Mental Barrier to refactoring and modernization
    * 개발자들이 shared library 변경을 꺼려하는 경향이 있다.
        * Fear: 다른 서비스에 어떤 영향이 있는지 모르겠어요. 다른 서비스 도메인을 잘 몰라서 어떤 영향인지 예측이 안되요.
        * Avoided effort: library update하기 위해 많은 일을 해야 한다.
            * library 변경, 테스트, jenkins build, release, 모든 microservice에 library 버전 update. 모든 microservice build, 모든 microservice test... 이 많은 것을 할 시간이 없다.
* Exceptions
    * Spring, Apache, Lombok 같은 open source는 충분한 가치가 있다.
    * 기술적 관심으로 library를 가지는 것은 괜찮다. (logging, monitoring 등)
    * business나 domain logic을 library로 이동하지 마라.
    * 예를 들어 도메인 모델이 library에 있다면 새로운 요구사항이 들어왔을때 이 모델을 사용하는 모든 microservice를 update해야 한다.
    * 모든 service는 bounded context를 가지고 있다.
    * library를 사용하는 모든 service가 같은 팀에서 유지된다면 괜찮다.
    * 변화가 한팀 내에서 관리될 수 있다. 
* Alternatives
    * 중복을 수용하라. 
    * shared service를 사용하라. 
* Conclusion
    * shared nothing 접근을 따라야 한다.


> Q. 확장큐브의 X축 확장은 EER 이중화가 이에 해당하는건가요? (38 page)

X축은 동일역할을 하는 여러대의 서비스를 의미하며 EER의 이중화와 동일하다.
EER과 같이 2대 구성이 아닌 N대로 무한 확장 가능한 구조이며 이를 위해 service discovery 및 api gateway가 필요하다.

> 59 page 장애처리 시 msa가 모놀리식보다 에러원인을 찾기 어려울 것 같은데 어떤 시스템을 이용하여 어떻게 해결하는지 설명해주세요~

이 책 461p 참고

* 로그 수집 패턴
    * 서비스에 로그파일로 저장되면 로그를 확인하기 어렵다. AWS 람다는 영구적인 파일 시스템 자체가 없다.
    * 로그 수집 인프라가 필요하다.
        * ELK(elastic search/logstash/kibana)
        * fluentd, apache flume
        * aws cloudwatch
* 분산 추적 패턴
    * 특정 api가 느려진 원인? 어디를 봐야 할까? api gateway?, service
    * 분산 추적 서버: open zipkin
    * 인스트루멘테이션 라이브러리: 스프링 클라우드 슬루스(spring cloud sleuth)
* 예외 추적 패턴
    * 서비스에서 예외가 발생하면 무조건 예외 추적 서비스에 보고하도록 구성
    * 예외 추적 서비스 라이브러리: 허니배저(HoneyBadger)

> Q. 1.6.2 상용 패턴 구조의 예시를 보여주실 수 있을까요? (52 page)

없습니다~











