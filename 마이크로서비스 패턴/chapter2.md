# 2장. 분해 전략

## 2.1 마이크로서비스 아키텍쳐란 무엇인가?
 * 마이크로서비스 아키텍쳐는 관리성, 테스트성, 배포성이 높은 어플리케이션을 구축하기 위한 아키텍쳐 스타일.
 * 컴퓨팅 시스템의 소프트웨어 아키텍처는 소프트웨어 엘리먼트(element)와 그들 간의 관계, 그리고 이 둘의 속성(property)으로 구성된 시스템을 추론하는 데 필요한 구조(structure)의 집합.
 * 소프트웨어 아키텍쳐 4+1 뷰 모델
   1. 논리 뷰(logical view) : 상속(inheritance), 연관(association), 의존(depends-on) 등 클래스와 패키지의 관계.
   2. 구현 뷰(implementation view) : 빌드 시스템의 결과물. 모듈과 컴포넌트로 구성된다. 자바의 JAR파일.
   3. 프로세스 뷰(process view) : 런타임 컴포넌트, 각 엘리먼트는 개별 프로세스고, IPC(Inter-Process Communication)는 프로세스 간 관계.
   4. 배포 뷰(deployment view) : 프로세스가 머신에 매핑되는 방법.
 * 아키텍쳐의 중요성 
   - 애플리케이션의 요건은 크게 두가지로 기능요건(애플리케이션이 어떤 기능, 동작을 해야하는지)과 품질 요건(확장성, 신뢰성 등..)으로 나누어 짐.
   - 아키텍쳐 선택에 따라 기능/품질 요건의 트레이드 오프가 생김.
 * 계층화 아키텍처 스타일 (Layered Architecture)
   - 3계층 아키텍쳐의 논리뷰
     1. Presentation Layer : UI 또는 외부 API 관련
     2. Business Logic Layer : 비즈니스 로직 관련
     3. Persistence Layer : DB 관련
   - 계층와 아키텍쳐는 아래와 같은 단점
     1. 표현계층이 하나다, 애플리케이션을 호출하는 시스템은 하나가 아님.
     2. 영속화 계층이 하나다, 애플리케이션과 상호작용하는 DB는 하나가 아님.
     3. 비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다, 이론적으로 이런 의존성 때문에 DB없이 비즈니스 로직을 테스트하는 것을 불가능.
 * 육각형 아키텍쳐 스타일
   - 논리뷰 중심의 계층화 아키텍쳐 스타일의 대안.
   
     ![육각형 아키텍쳐](https://media.vlpt.us/images/labyu/post/02266a75-8412-4d2b-bf91-60bb6abddc57/image.png)
   - 어댑터 종류     
     1. 인바운드 어댑터 : 외부에서 들어온 요청을 인바운드 포트를 호출해서 처리 (e.g. Rest end point)
     2. 아웃바운드 어댑터 : 비즈니스 로직에서 들어온 요청을 외부 애플리케이션/서비스를 호출해서 처리하고, 이후 (e.g. DAO Class, proxy 클래스) 이벤트를 발행하기도 함.
 * 서비스
   - 서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트. 서비스는 클라이언트가 자신이 서비스하는 기능에 접근할 수 있도록 커맨드, 쿼리, 이벤트로 구성된 API를 제공 함
   - 서비스는 크게 command(명령 CUD)와 Query (조회 R)로 구분 됨.
   - 서비스는 API를 제공해 내부 구현 상세를 캡슐화 함.
   - API 서비스는 2개의 아댑터로 구분 됨.
     1. 작업 아댑터 (operations adapter) : 비지니스 로직 호출.
     2. 이벤트 아댑터 (events adapter) : 비지니스 로직이 리턴하는 이벤트.
 * 느슨한 결합
   - API를 통해서만 동작이 되기 때문에 서비스가 직접 DB 스키마에 접근 할 수 없어 서비스 결합이 느슨해 짐.
 * 공유 라이브러리
   - 재사용 빈도가 높고, 변경되지 않는 기능은 공유해서 사용한다.
   - 서비스간 결합도가 높아지는것을 주의해야 함.
 * 서비스 규모
   - 마이크로서비스의 규모는 중요하지 않음
   - 상황, 비지니스에 따라 정해 질 수 있음.
## 2.2 마이크로서비스 아키텍쳐 정의
 * 총 3단계로 이루어지며 다음과 같은 단계로 이루어 짐.   
   - 애플리케이션 요건을 핵심 요청으로 추출
   - 어떻게 여러 서비스로 분해할지 결정
   - 서비스별 API 정의
   ![3단계 서비스 정의](https://thebook.io/img/007035/080.jpg)
 * 시스템 식별 작업을 위한 2단계
   - 1단계 : 보케블러리를 제공하는 핵심 클래스로 구성된 고수준의 도메인 모델 생성
   - 2단계 : 시스템 실별 후 도메인 모델 관점에서 시스템 작업 정의 및 기술.
 * 서비스 정의 : 하위 도메인 패턴별 분해
   - DDD의 개념을 이용한다. 그 중 ubiquitous language(공용 언어), sub-domain(하위 도메인), bounded context(경계 컨텍스트) 개념이 마이크로서비스 아키텍처를 구현하는데 용이 함.
   1. 분해
     - SRP(Single Responsibility Principle, 단일 책임원칙)
     - CCP(Common Closure Principle, 공동 폐쇄 원칙)
   2. 서비스 분해 장애 요소
     - 네트워크 지연 : 서비스간 왕복 횟수를 줄일 수 있도록 배치 API를 구현하거나 비싼 IPC를 이용.
     - 동기 IPC로 인한 가용성 저하 : 비동기 메시징을 이용해 느슨한 결합으로 가용성을 높여야 함.
     - 여러 서비스에 걸쳐 데이터 일관성 유지 : 사가라는 방식으로 트랜잭션 관리.
     - 데이터의 일관된 뷰 확보
     - 분해를 저해하는 만능 클래스 : 만능 클래스를 만들지 말자. MSA에서는 어느정도의 중복은 허용.
   3. 서비스 API 정의
     - 시스템 작업을 서비스 배정
     - 서비스 간 협동 지원에 필요한 API 결정
## 2.3 마치며
 * 아키텍쳐는 애플리케이션 개발 속도에 직접 영향을 주는 품질 특성을 좌우 함.
 * 마이크로서비스 아키텍쳐는 애플리케이션 관리성,테스트성,배포성을 높이는 아키텍쳐 스타일.
 * 마이크로서비스는 기술적 괌심사보다 비지니스 능력, 하위 도메인 등 비지니스 관시사 위주로 구성됨.
 * 서비스 분해 패턴은 크게 두 가지.
   - 비지니스 능력에 따른 분해 : 비지니스 아키텍쳐 기반
   - 하위 도메인에 따른 분해 : DDD 개념 기반
 * DDD를 적용하면, 만능 클래스를 방지/제거 할 수 있음.
 
## Q&A
1. 느슨한 결합에 attic share는 포함되지 않는것인가요? share같은 경우 조직은 따로 한조직으로 묶는건가요? share변경 시 테스트는 모든 서비스 조직이 테스트하여야할까요?
 - share는 원칙적으로 비지니스 로직을 포함하지 않는다.
   attic share는 기술적 부분만 포함되어 있고, share 변경시 관련 연관된 모든 기능이 테스트 되어야 된다고 봄(다른 의견 취합 필요)
2. 서비스별로 개발조직이 다르면, 각 서비스별로 사용하는 패턴, 용어, 변수명 규칙 등을 다른 조직에 공유하고, 정의할 필요가 있을까요?
 - 다른 조직 공유 : 해당 서비스를 이용하는 I/F 만 정의/공유 하면 됨 (e.g. attic 의 controller, adapter)
3. CCP(공동폐쇄원칙)에 따르면 하나의 요구사항에 따라 변경 영향이 있을 경우 동일한 패키지에 구성하는 것이라 말하는데, 만약 특정 요구사항으로 서로 다른 컴포넌트가 합쳐지거나 확장으로 인해 분리될 때 조직도 함께 변경되는걸까요?
 - CCP는 변경 사항을 하나의 패키지로 묶어 쓰레기통을 만든다는 의미로 해석중. (e.g. 변경도 높은 조회 업무를 elasticsearch에 묶어 놓음)
   패키지 분리/병합 요건은 case by case 로 건마다 다르게 해석 될 수 있다고 판단됨. 
4. UX도 MSA화 시켜서 구현하여야 한다고 알고 있는데, 그게 한 개의 페이지 당 하나의 컴포넌트만을 사용하는 것이 좋다는 걸까요?
 - [참고자료](https://martinfowler.com/articles/micro-frontends.html)
5. EER에서 만능(god) 클래스는 어떤게 있을까요?
 - js 에서는 ticket.js
 - account 등   
6. "서비스가 직접 DB와 통신하는 일은 불가능합니다"의 의미는 무엇인가요?
 - DB와 통식은 해당 컴포넌트에서만 가능하고, 외부에서 해당 repository에 접근 하려면 표준 spec을 통해 접근 해야 함. (e.g. attic의 resource, adapter)
7. 서비스를 단일 책임 원칙으로 분리하면 너무 작은 단위가 되지 않을까요?
 - 단일 책임의 범위는 비지니스 요건에 따라 다름
8. "한 가지 단점은 최종 일관성을 보장한다는 것입니다" <- 왜 단점이 되는건가요?
 - 기존 RDB와 다르게 Data의 복제 개념으로 실시간 동기화가 되지 않음 
 - [Eventual consistency](https://cloud.google.com/datastore/docs/articles/balancing-strong-and-eventual-consistency-with-google-cloud-datastore?hl=ko)
9. 마이크로서비스 아키텍처 정의 단계에서 서비스 정의를 할 때 비즈니스 능력별로 하는 것과 DDD 로 하는 방식이 있다고 하는데, 선후 관계가 있는 걸까요? 선택하는 것이라면 어떤 차이가 혹은 상황에서 적용 할 수 있을까요?
 - 책에 나온 예제를 보면 비즈니스 능력 식별은 bounded-context 를 뽑는것으로 보이며, DDD 방식으로 보입니다. (다른점을 잘 모르겠음.)
   이 미묘한 부분은 지도 편달 부탁 합니다 (--)(__)(--)