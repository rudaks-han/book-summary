## 부록 A. 추상화 기법

#### 추상화 기법

- 추상화는 도메인의 복잡성을 인지하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다.
- 추상화 기법
  - 분류와 인스턴스화
    - 분류: 객체의 세부 사항을 숨기고 인스턴스 간 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정
    - 인스턴스화: 분류의 역. 범주로부터 객체를 생성하는 과정
  - 일반화와 특수화
    - 일반화: 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적 특성을 강조
    - 특수화: 일반화의 역
  - 집합과 분해
    - 집합: 부분과 관련된 세부 사항을 숨기고 부분을 사용해 전체를 형성하는 과정
    - 분해: 전체를 부분으로 분리하는 과정
- 객체지향은 동일한 추상화 기법을 프로그램의 분석, 설계, 구현 단계에 걸쳐 일관성 있게 적용할 수 있다.

#### 분류와 인스턴스화

- 객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다.
- **개념**이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다(Martin 1998)
  - 예) 자동차: 바퀴를 이용해 사람들을 한 장소에서 다른 장소로 운반하는 운송수단
- 범주와 개념은 인간이 실세계를 바라보는 인식의 형태를 빚는다.
- 세상에 존재하는 객체에 개념을 적용하는 과정을 **분류** 라고 한다(Martin 1998) 분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다.
- 분류를 통해 '수많은 개별 현상'(→ 객체)을 '하나의 개념'(→ 타입)으로 다룬다. 즉, **분류는 객체를 타입에 연관시키는 것**이다. 
- 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 **인스턴스화** 또는 **예시** 라고 한다.
- **타입** 은 개념과 동의어이며 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어를 의미한다. 이런 관점에서 **분류** 란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하므로 객체를 타입의 **인스턴스** 라고 한다.

> 분류는 객체와 타입 간의 관계를 나타낸 것이다. 어떤 객체가 타입의 정의에 부합할 경우 그 객체는 해당 타입으로 분류되며 자동으로 타입의 인스턴스가 된다.

- 객체를 타입에 따라 분류하기 위해 세가지  관점에서의 정의가 필요하다
  - 심볼: 타입명
  - 내연: 타입의 완전한 정의. 내연의 의미로 객체가 타입에 속하는지 확인할 수 있다.
  - 외연: 타입에 속하는 모든 객체 집합
- 분류 방법
  - 다중 포함 여부: 단일 분류, 다중 분류
  - 타입 변경 여부: 동적 분류(자신이 속하는 타입 변경 가능), 정적 분류(객체가 자신의 타입 변경 불가)
  - 다중 분류와 동적 분류는 개념적 관점에서 도메인 분석에 유용하지만 구현으로 옮기기는 쉽지 않다. 
  - 대부분의 객체지향 언어는 단일 분류와 정적 분류만을 지원한다.
- 객체지향 프로그래밍 언어로 '타입을 구현하는' 가장 보편적인 방법은 **클래스** 를 이용하는 것이다.
- 객체지향 패러다임은 아리스토텔레스의 분류법의 근간을 형성하는 아이디어를 기반으로 한다.
  - 아리스토텔레스는 세계에 존재하는 객체들에 대한 객관적 분류 체계가 존재한다고 가정했다.
  - 본질적(essential) 속성: 사물의 가장 핵심적이고 필수불가결한 속성. 
  - 우연적(accidental) 속성: 본질적이지 않은 속성.
- 클래스는 객체가 공유하는 본질적인 속성을 정의한다. 대부분의 객체지향 언어는 우연적인 속성은 표현할 수 없다. 따라서 동일한 범주에 속하는 객체는 모두 동일한 속성을 가져야만 한다.
- 클래스가 없는 프로토타입 언어(자바스크립트 등)에서 분류와 인스턴스화는 프로토타입이라는 객체의 복사를 통해 이뤄진다.

#### 일반화와 특수화

- 린네의 분류법 상의 계층 구조에서처럼 계층 상위에 위치한 범주를 계층 하위에 위치한 범주의 **일반화** 라고 하고 계층 하위에 위치한 범주는 계층 상위에 위치한 범주의 **특수화** 라고 한다.
- 객체지향에서 범주는 개념이고, 개념은 타입이므로, 일반화와 특수화는 계층 구조 안에 존재하는 타입 간의 관계를 의미한다.
- 더 일반적이라면 'supertype' 이라고 하고, 더 특수하다면 'subtype' 이라고 한다.

> 아리스토텔레스는 기존 범주가 가진 속성을 새로운 범주가 포함할 경우 새로운 범주는 기존 범주를 확장해 정의할 수 있다고 봤다. 즉 새로운 범주의 속성은 자신의 정의한 본질적 속성에 기존 범주의 본질적 속성을 추가한 것이다.

- 서브타입은 슈퍼타입이 가진 본질적 속성과 함께 자신만의 속성을 가진다. 내연의 관점에서 슈퍼타입의 정의가 더 일반적이라는 것을 의미한다.
- 내연의 관점에서 일반화와 특수화는 범주 간의 논리적인 추론을 가능하게 한다. 계층의 모든 서브타입은 슈퍼타입의 속성을 공유한다고 예상할 수 있다.
- 일반화의 특징을 이용하면 부분적인 사실을 통해 복잡한 사실에 대한 논리적 추론이 가능해진다. 
- 크레이그 라만: 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 '100% 규칙' 과 'is-a 규칙' 을 준수해야 한다.
  - 100% 규칙: 타입의 내연. 슈퍼타입의 정의가 100% 서브타입에 적용되어야만 한다. 서브타입은 속성과 연관관계면에서 슈퍼타입과 100% 일치해야 한다.
  - is-a 규칙: 타입의 외연. 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함되어야 한다(부분집합).  일반화 관계. subtype is a supertype. 예) 고양이는 육식동물이다. 
- 프로그래밍 언어에서 일반화, 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간의 **상속** 을 사용하는 것이다.
- 일반화 원칙: 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응해야 한다. (대체 가능성)
  - 구조적 순응(structural conformance) : 속성과 연관관계에 대한 대체 가능성. 100% 규칙.
    - Person 의 서브타입 Employee 는 Person.name 속성을 Employee 도 가진다. 
  - 행위적 순응(behavioral conformance): 행위가 동일한 계약을 기반으로 하느냐에 대한 대체 가능성. 리스코프 치환 원칙(Liskov substitution principle)
    - Person.getAge() 가 메세지 응답으로 나이를 반환한다면 Employee.getAge() 도 나이를 반환해야 한다.
- 상속의 용도
  - subtyping : 서브클래스가 슈퍼클래스를 대체하는 것. 설계의 유연성이 목표. =인터페이스 상속.
  - subclassing : 서브클래스가 슈퍼클래스를 대체할 수 없는 것. 코드의 중복 제거와 재사용 목적. =구현 상속
- 일반화를 위한 subtyping 은 특정 기대 집합에 대한 구조적, 행위적 순응 관계를 의미하며 대체 가능성을 내포한다.
- 여러 클래스로 구성된 상속 계층에서 수신된 **메시지**를 이해하는 기본적인 방법은 클래스 간의 **위임(delegation)** 을 사용하는 것이다.
  - 수신 메시지를 이해할 수 없으면 메시지를 부모 클래스로 위임. 계층 내 처리하는 클래스가 없으면 최상위까지 계속.
- 클래스가 없는 프로토타입 언어에서 상속은 객체와 객체 간의 관계로 이뤄진다. [^1] [^2]
  - 어떤 객체를 특정 객체 타입의 특수화로 만들거나 행동 공유를 하려면 상속 관계를 통해 연결한다.
  - 메시지도 동일하게 위임 메커니즘에 의해 처리된다. 클래스 대신 자식 객체와 부모 객체 간 위임.

#### 집합과 분해

- 호라와 템프스의 우화 : 1000개의 부품으로 구성된 시계를 효율적으로 조립하는 유일한 방법은 작은 부품으로 구성된 안정적인 형태의 중간 부품을 이용해서 조립하는 것이다.
  - 복잡성은 '계층'의 형태를 띤다
  - 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 '안정적인 형태'의 수와 분포에 의존한다.
- 안정적인 형태의 부분으로부터 전체를 구축하는 행위를 **집합**이라고 하고 집합과 반대로 전체를 부분으로 분할하는 행위를 **분해** 라고 한다.
- 집합의 가치는 복잡성을 줄일 수 있다는 데 있다. 불필요한 세부 사항을 배제하고 큰 그림에서 대상을 다룰 수 있게 한다. -> 추상화 메커니즘인 동시에 캡슐화 메커니즘이다.
- 집합의 경계가 모호한 경우도 많다. 본능적으로 가진 '그릇 은유'를 통해 경계가 존재하지 않는 곳에서도 인위적인 집합을 창조할 수 있다. (삶으로서의 은유 - Lakoff, 2003)
- 객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 **합성 관계**를 사용한다. 예) 주문 - 주문항목
  - 합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다. 
- 단순한 물리적 통로로 연결된 연관 관계. 예) 주문 - 상품
- 합성 관계와 연관 관계의 차이
  - 합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거된다
  - 연관 관계로 연결된 객체는 생명주기와 관련된 어떤 제약도 없다
- 소프트웨어에서 구조를 단순화 하기 위해서는 서로 관련성 높은 클래스 집합을 논리적 단위로 통합해야 한다. 이처럼 상공에서 바라본 소프트웨어 전체 구조를 표현하기 위한 구성 요소를 **패키지** 또는 **모듈** 이라고 한다.
- 합성 관계가 내부 객체를 감춰 내부 구조를 추상화 하는 것처럼 패키지는 내부 클래스들을 감춤으로써 시스템구조를 추상화 한다.


----------------

[^1]: MDN web docs: 상속과 프로토타입 https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain
[^2]: 자바스크립트 상속과 프로토타입 개념정리 https://shlee1353.github.io/2019/07/05/js-prototype-inheritance/
