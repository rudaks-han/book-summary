# 8장 OCP: 개방-폐쇄 원칙

개방-폐쇄 원칙이라는 용어는 1988년에 버트란트 마이어가 만들었는데, 다음과 같다.

> 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

다시 말해 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 산출물을 변경해서는 안된다.

소프트웨어 아키텍처를 공부하는 가장 근본적인 이유가 바로 이 때문이다. 요구사항을 살짝 확장하는데 소프트웨어를 엄청나게 수정해야 한다면, 그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패에 맞닥뜨린다는 것이다.



## 사고 실험

재무제표를 웹 페이지로 보여주는 시스템이 있다고 생각해보자. 음수는 빨간색으로 출력한다.

이해관계자가 동일한 정보를 보고서 형태로 변환해서 흑백 프린터로 출력해 달라고 요청했다고 해보자. 이 보고서에는 페이지 번호가 제대로 매겨져 있어야 하고, 페이지마다 적절하 머리글과 바닥글이 있어야 하며, 표의 각 열에는 레이블이 있어야 한다고 해보자. 또한 음수는 괄호로 감싸야 한다.

당연히 새로운 코드를 작성해야 한다. 그렇다면 원래 코드는 얼마나 많이 수정해야 할까? 

소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양이 가능한 한 최소화될 것이다. 이상적인 변경량은 0이다.

어떻게 하면 될까? 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙 SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙 DIP) 변경량을 최소화할 수 있다.

단일 책임 원칙을 적용하면 데이터 흐름을 그림과 같은 형태로 만들 수 있다. 



<img src="chapter-08.assets/8_1.png" alt="SRP 적용하기" style="zoom:67%;" />



여기서 얻을 수 있는 가장 중요한 영감은 보고서 생성이 두 개의 책임으로 분리된다는 사실이다. 하나는 보고서용 데이터를 계산하는 책임이며, 나머지 하나는 이 데이터를 웹으로 보여주거나 종이로 프린트하기에 적합한 형태로 표현하는 책임이다.

이처럼 책임을 분리했다면, 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스코드 의존성도 확실히 조직화해야 한다. 또한, 새로 조직화한 구조에서 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다.

이러한 목적을 달성하려면 처리 과정을 클래스 단위로 분할하고, 이들 클래스를 컴포넌트 단위로 구분해야 한다.



<img src="chapter-08.assets/8_3.png" alt="컴포넌트 관계는 단방향으로만 이루어진다." style="zoom:50%;" />



모든 컴포넌트 관계는 단방향으로 이루어진다는 뜻이다.

위의 그림에서 interactor가 업무 규칙을 포함하고 있다는 것이다. interactor는 애플리케이션에서 가장 높은 수준의 정책을 포함한다.



## 결론

OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템에 너무 많은 영향을 받지 않도록 하는데 있다. 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.





